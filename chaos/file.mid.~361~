;;; -*- Mode: MIDAS -*-

IFNDEF ITS,[
IFE .OSMID-SIXBIT/ITS/,ITS==1
.ELSE ITS==0
];IFNDEF ITS
IFNDEF 10X,[
IFE .OSMID-SIXBIT/TENEX/,10X==1
.ELSE 10X==0
];IFNDEF 10X
IFNDEF 20X,[
IFE .OSMID-SIXBIT/TWENEX/,20X==1
.ELSE 20X==0
];IFNDEF 20X
IFNDEF TNX, TNX==1-ITS

; Things to do:
; COMRFO should quote embedded spaces, colons, semicolons, ideally.
; COMPFN should become more robust

IFN ITS, TITLE FILE JOB FOR ITS
IFN 20X, TITLE FILE JOB FOR TOPS-20
IFN 10X, TITLE FILE JOB FOR TENEX

IFN ITS,[
NIMPUR==1	;Number of low impure pages
PURBEG==NIMPUR*2000
]	;END IFN ITS
IFN TNX,[
.DECSAV
NIMPUR==3	;Number of low impure pages
PURBEG==NIMPUR*1000
JOBSYM=116	;Pointer to symbol table, in our own core
NSYMPG==2	;Number of pages left for symbol table
]	;END IFN TNX

;AC definitions
F=0                             ;FLAGS ET AL.

;;; AC's 1 thru 3 (and sometimes 4) are used for Tops-20 JSYS'
;;; On Tenex, the GETER JSYS will smash AC's 4-10 as well.

T=4                             ;SUPER TEMPORARIES
TT=5

A=6                             ;NOT SO SUPER TEMPORARIES, BUT FOR GENERAL USE
B=7
C=10
D=11

IDX=12				;INDEX INTO TABLES POINTING TO FILE CURRENTLY BEING HACKED
                                ; LOW ORDER BIT 0=INPUT, 1=OUTPUT
BP=13                           ;POINTER INTO PACKET
BYTE=14                         ;CURRENT BYTE BEING HACKED
FHN=15                          ;CURRENT FILE HANDLE
BC=16                           ;BYTE COUNT REMAINING IN CONTROL PACKET

P=17                            ;PDL POINTER, OF COURSE (THIS BETTER BE 17 FOR TOPS-20)

IFN ITS,[
;Get CHAOS definitions
.INSRT SYSTEM;CHSDEF
]	;END IFN ITS

IFN TNX,[
	LOC 140
.INSRT FILDEF.MID
]	;END IFN TNX

%CPMXW== 126.		;Note: we want max over ALL systems here ...
%CPMXC== 488.

;IFNDEF CHPMXW, CHPMXW==%CPMXW-%CPKDT
;IFNDEF CHPMXC, CHPMXC==%CPMXC

;; Flag bits
F.FHN==:1_0                     ;IF SET THERE WAS A VALID FILE HANDLE IN THE CONTROL REQUEST
F.NWL==:1_1                     ;COMEUS HAS SEEN A NEWLINE
F.PRB==:1_2                     ;DOING A PROBE
F.QFP==:1_3                     ;QFASLP
F.FN1==:1_4                     ;Guess....
F.FN2==:1_5
F.DEV==:1_6
F.DIR==:1_7
IFN TNX,[
F.SPAC==:1_8			;A space has been seen while building error code
F.NRJ==:1_9			;Don't release JFN in CLOSIT
F.ENA==:1_10.			;Enable after login
]	;END IFN TNX
F.DEF==:1_11.			;:CHARACTERS :DEFAULT

IFN ITS,[
;; I/O CHANNELS
UTILCH==0                       ;UTILITY CHANNEL: PROBES, TTY

;;; The CHAOS channels must be contiguous
CTRLI==1                        ;CONTROL CONNECTION INPUT
CTRLO==2                        ;CONTROL CONNECTION OUTPUT

ERRCH==17			;Error channel

;; REMAINING CHANNELS FOR USE FOR REAL I/O
;; GROUP 1:
;; 3, DATA CONNECTION IN.  4, DATA CONNECTION OUT
;; 11, INPUT FILE.  12, OUTPUT FILE

;; GROUP 2:
;; 5, DATA CONNECTION IN.  6, DATA CONNECTION OUT
;; 13, INPUT FILE.  14, OUTPUT FILE

;; GROUP 3:
;; 7, DATA CONNECTION IN.  10, DATA CONNECTION OUT
;; 15, INPUT FILE.  16, OUTPUT FILE

;; EXTRA ENTRY FOR PROBING

CHACHN:	3 ? 4 ? 5 ? 6 ? 7 ? 10 ? -1

CHALOW==:1
CHAHIG==:10

CHABIT: 10 ? 20 ? 40 ? 100 ? 200 ? 400

DATCHN:	11 ? 12 ? 13 ? 14 ? 15 ? 16 ? UTILCH

MAXIDX==6                       ;NUMBER OF INFORMATION CHANNELS.  N/2 INPUT, N/2 OUTPUT
                                ;LOW ORDER BIT 0=INPUT, 1=OUTPUT
]	;END IFN ITS

IFN TNX,[
PRILE1:	0			;Three locations for storage of old PC at interrupt time
PRILE2:	0
PRILE3:	0

LV1ACS:	BLOCK 20		;Room for the ACs
LV1SAC:	0			;Routine to be JSR'ed to to save AC's at level 1
	MOVEM 0,LV1ACS
	MOVE 0,[1,,LV1ACS+1]
	BLT 0,LV1ACS+17
	MOVE 0,LV1ACS
	JRST @LV1SAC

MAXIDX==16.

CHABIT:	IRPS BITPOS,,[0,1,2,3,4,5,23,24,25,26,27,28,29,30,31,32,33]
	1_<35.-BITPOS!.>
	TERMIN

CHAICN:	0,,1
	2,,3
	4,,5
	23.,,24.
	25.,,26.
	27.,,28.
	29.,,30.
	31.,,32.
	33.,,33.
	;; Channels 34. and 35. are reserved by monitor for toplevel job!

CHAJFN:	BLOCK MAXIDX+1
]	;END IFN TNX

;;; Impure tables

;;; Per data connection tables

; File handle, Status, Byte size, Bytes per word, Buffer, Buffer pointer, Buffer count,
; Device, Filename 1, Filename 2, Sname, Storage over IOC errors, File bytes remaining (Text),
; Sync mark routine, Sync mark routine arg, Last word, IOC error continuation adr, JFN,
; JFN to rename file to
IRPS TABLE,OPS,[FHN,STA,BYT,BPW,BUF,BPT,BCT,DEV\FN1\FN2\SNM\IOC,LEN,SYA,SYN,LWD,ICN,JFN/RFJ/]
FLAG=0
IFSE [OPS][,]FLAG=1
IFSE [OPS][/]IFN TNX, FLAG=1
IFSE [OPS][\]IFN ITS, FLAG=1
IFN FLAG,[
DAT!TABLE: BLOCK MAXIDX+1
]
	TERMIN

;Status contains:
ST%CLO==:0			;Closed state (initial state)
ST%OPN==:1			;Open state
ST%ASY==:2			;Asynchronous marked state
ST%SYN==:3			;Synchronous marked state
ST%EOF==:4			;Eof state

ST.SYN==:(1_22)			;Synchronous mark (expected, on input; needed, on output)
ST.BIN==:(1_23)                 ;Binary mode
ST.UNC==:(1_24)			;The last asynchronous error is uncontinuable
ST.DEL==:(1_25)			;Deleted files are ok
IFN TNX,[
ST.TEM==:(1_26)			;Temporary file
]	;END IFN TNX
ST.OUT==:(1_27)			;COMGJF wants file for output
ST.RAW==:(1_30)			;Raw: no character translation whatsoever
ST.SUI==:(1_31)			;Super-image: don't treat rubouts specially
ST.DIR==:(1_32)			;This channel is in use for directory hackery
ST.ACT==:(1_43)			;This channel is active (sign bit!)
IFN TNX,[
ST.PON==:(1_33)			;COMGJF should do parse only
];TNX
ST.NOK==:(1_34)			;New file ok for completion
ST.FST==:(1_35)			;Fast directory listing option
ST.ALD==:(1_36)			;Directories only listing option (ALL-DIRECTORIES)
ST.PDT==:(1_37)			;Don't update access dates, etc.

;Opcodes:
CO%SYN==:%CODAT+1               ;Synchronous mark
CO%ASY==:%CODAT+2		;Asynchronous mark
CO%NOT==:%CODAT+3		;Notification
CO%BDT==:%CODAT\100             ;Binary data
CO%TXT==:%CODAT                 ;Text opcode
CO%EOF==:%COEOF                 ;EOF opcode

%CLEND==400000

; Packets
CTLPKI:	BLOCK %CPMXW	;control in
CTLPKO:	BLOCK %CPMXW	;control out
REAPKT:	BLOCK %CPMXW
WRIPKT:	BLOCK %CPMXW
ASYPKT:	BLOCK %CPMXW

;;; Random impure data
DEBUG:	-1			;-1 if debugging, +1 means dump ourselves if error (-20 only)
CHPMXW:	%CPMXW-%CPKDT		; Left as-is for ITS, but adjusted for TOPS-20
CHPMXC:	%CPMXC

IFN TNX, DMPACS: BLOCK 20

PDL:	-177,,.+1               ;Size carefully chosen to give 1K impure
	BLOCK 177
FHNOUT:	BLOCK 1                 ;WORD TO OUTPUT FILE HANDLE FROM
	0
PTCVER:	0			;Protocol version number
IFN ITS, MACNAM: SIXBIT /AI/	;The machine we are on, use AI if info not available
CLODAT:	0			;Temporary storage by CLOSE operation
CLOLEN:	0
ERRCOD:	0                       ;Error code returned by .CALL OPEN
ERRLEN==:200
ERRBUF:	BLOCK ERRLEN/5
IFN ITS, SSYDF2: 0		;Temporary storage of old DF2 word

TRANID:	0			;Transaction ID
	0
PKTLOC:	CTLPKO			;COMCTL (et al.) use this as packet address
USERID:	0			;User ID, set by LOGIN.  Must be non-zero to do OPEN's
DIRPDL:	0			;Saved stack for unwinding directory output

IFN ITS,[
HSNAME:	0			;User HSNAME, sets files' authors
DIRLCK:	0			;Only one channel can use DIRBUF
]	;END IFN ITS
IFN TNX,[
RESLEN==:200
RESBLK:	BLOCK RESLEN/5
CTLJFN:	0
INQBLK:
GTJBLK:				;For long call GTJFN for completion
DIRINF:	BLOCK 30		;For GTDIR info (in LOGIN command) and GTFDB
JFNSTR:	BLOCK 30.		;For building JFN's, 149 chars should be ok
INQBLL==.-INQBLK
USRNUM:	BLOCK 1
DWNTIM:	BLOCK 1
TIMINF:	BLOCK 1

]	;END IFN TNX

IMPLOC==.
LOC PURBEG

;;; Pure tables
IFN ITS,[
CTLOUT:	SETZ
	SIXBIT /PKTIOT/
	%CLIMM,,CTRLO
	%CLIMM+%CLEND,,CTLPKO

CTLINP:	SETZ
	SIXBIT /PKTIOT/
	%CLIMM,,CTRLI
	%CLIMM+%CLEND,,CTLPKI
]	;END IFN ITS

;;; Macros
DEFINE CERR CODE,TEXT
	JSP D,COMERR
	 SKIPA
	  '!CODE,,[ASCIZ \F TEXT\]
	TERMIN

DEFINE AERR CONTIN,CODE,TEXT
	JSP D,ASYERR
	 JRST .+3
	  '!CODE,,[ASCIZ \F TEXT\]
	  CONTIN
	TERMIN

DEFINE IOCERR ADR
	JSP D,ICCERR
	 SKIPA
	  ADR
	TERMIN

;;; Main program.  Startup, initialization, control connection main loop

FILE:
IFN ITS,SETZB F,DIRLCK
IFN TNX,SETZ F,
	MOVE P,PDL
IFN ITS,[
	.SUSET [.ROPTION,,T]
	TLO T,OPTINT\OPTOPC	;TURN ON NEW STYLE INTERRUPTS
	.SUSET [.SOPTION,,T]
	.SUSET [.SDF1,,[%PIDBG+%PIDWN]]	;DEFER SYS DOWN, SYS DEBUG
	.SUSET [.SMASK,,[%PIIOC+%PIDBG+%PIDWN]] ;ENABLE INTERRUPTS
	.CALL [ SETZ            ;GET OUT MACHINE'S NAME
		SIXBIT /SSTATU/
		MOVEM A ? MOVEM B ? MOVEM T ? MOVEM T ? MOVEM T
		SETZM MACNAM]
	 JFCL
	SKIPLE A		;GET INITIAL HIT OF DOWN/DEBUG INTERRUPTS
	 .SUSET [.SIPIRQC,,[%PIDWN]]
	SKIPE B
	 .SUSET [.SIPIRQC,,[%PIDBG]]
        .CALL [	SETZ            ;ASSIGN CHAOSNET CONTROL CHANNELS
		SIXBIT /CHAOSO/
		%CLIMM,,CTRLI
		%CLIMM,,CTRLO
		%CLIMM,,5 ((SETZ))]
	 .LOGOUT 1,
	MOVEI T,%COLSN          ;LISTEN FOR OUR CONTACT NAME
	DPB T,[CTLPKO+$CPKOP]
	MOVE T,[.BYTE 8 ? "F ? "I ? "L ? "E]
	MOVEM T,CTLPKO+%CPKDT
	MOVEI T,4
	DPB T,[CTLPKO+$CPKNB]
	.CALL CTLOUT            ;OUTPUT THE LISTEN
	 .LOSE %LSSYS
	MOVEI T,30.*30.		;30. SEC TIMEOUT
	SKIPGE DEBUG		;UNLESS DEBUGGING
	 HRLOI T,177777
	.CALL [	SETZ            ;WAIT FOR A RESPONSE OR TIMEOUT
		SIXBIT /NETBLK/
		%CLIMM,,CTRLO
		%CLIMM,,%CSLSN
		T
		SETZM TT]
	 .LOSE %LSSYS
	CAIE TT,%CSRFC		;RFC RECEIVED?
	 .VALUE
	.CALL CTLINP            ;READ RFC PACKET
	 .LOSE %LSSYS
	LDB T,[CTLPKI+$CPKOP]
	CAIE T,%CORFC
	 .VALUE
	MOVE P,PDL
	PUSHJ P,CHKPVR		;CHECK PROTOCOL VERSION NUMBER
	 .VALUE			;ALREADY WILL HAVE SENT CLS IF NO GOOD
	MOVEI T,%COOPN		;SEND OPN BACK
	DPB T,[CTLPKO+$CPKOP]
	.CALL CTLOUT
	 .LOSE %LSSYS
	SKIPGE DEBUG		;DEBUGGING?
         JRST CTLLOP            ;YES, SO DON'T TRY TO LOGIN
	LDB T,[$CPKSA CTLPKI]	;GET SOURCE HOST ADDRESS
	MOVE TT,[SIXBIT /000C00/] ;CONVERT HOST NUMBER TO SIXBIT
	DPB T,[220300,,TT]
	LSH T,-3
	DPB T,[300300,,TT]
	LSH T,-3
	DPB T,[360300,,TT]
	.SUSET [.RUIND,,T]	;INCORPORATE USER INDEX ALSO
	DPB T,[000300,,TT]
	LSH T,-3
	DPB T,[060300,,TT]
	LSH T,-3
	DPB T,[170100,,TT]	;C77 + 1 = K00 TO AVOID DUPLICATIONS
	MOVE T,TT		;SAVE COPY FOR XUNAME
	MOVEI A,100(TT)		;DON'T LOOP FOREVER, ONLY 100 TIMES
CHALS1:	CAIN A,(TT)
	 .VALUE			;I DON'T THINK THIS CAN HAPPEN, BUT IT DOES ANYWAY
	.CALL [SETZ
	       SIXBIT /LOGIN/
	       TT ? [SIXBIT /CHAOS/] ? SETZ T]
	 AOJA TT,CHALS1		;ERROR, PERHAPS NEED TO TRY OTHER UNAME
	.SUSET [.SJNAME,,[SIXBIT /FILE/]]
	.CALL [SETZ ? 'DETACH ? MOVEI %JSELF ? ANDI 3 ]
	 .LOSE %LSSYS		;MAKE SELF SYSTEM-DAEMON FOR FAST RESPONSE

CTLLOP:	MOVE P,PDL              ;IN CASE OF ERROR, RESTORE PDL
	SETZ F,                 ;CLEAR FLAGS
	.SUSET [.SDF1,,[0]]	;ALLOW SYS DOWN, SYS DEBUG INTERRUPTS NOW
	.CALL CTLINP            ;GET NEXT CONTROL PACKET, HANG IF NECESSARY
	 .LOSE %LSSYS
	.SUSET [.SDF1,,[%PIDBG+%PIDWN]]	;DEFER THESE INTS WHILE PROCESSING
	LDB T,[CTLPKI+$CPKOP]
	CAIL T,%CODAT		;THIS A DATA PACKET?
	 JRST COMMAN		;YES, OK, GO DO A COMMAND FROM IT
	CAIE T,%COEOF		;LISP MACHINE WANT TO CLOSE THE CONNECTION?
         JRST CTLLOP            ;HMMM, BAD PACKET, IGNORE IT FOR NOW
CTLERR:
CTLDON:	.LOGOUT 1,              ;Go away immediately, do not RENMWO any output files
]	;END IFN ITS

IFN TNX,[
	RESET 			;Reset the Universe
	MOVEI 1,.FHSLF		;Setup our interrupt vector
	MOVE 2,[LEVTAB,,CHNTAB]
	SIR
	MOVEI 1,.FHSLF		;Turn on interrupt system
	EIR
	MOVEI 1,.FHSLF		;Enable interesting interrupts
	MOVE 2,[000747,,000004]
	AIC
IFN 20X,[
	MOVE 1,[SIXBIT /CHPMXT/]	; Get max packet size
	SYSGT
	TLNE 1,-1
	 JRST [	MOVE 1,[SIXBIT /LHOSTN/]	; Old flavor monitor
		SYSGT
		CAIE 1,54			; XX ?
		 SKIPA 1,300			; no - size is 300
		  MOVEI 1,488.			; yes - size is max
		JRST .+1 ]
	MOVEM 1,CHPMXC				; Set max # chars
	LSH 1,-2
	MOVEM 1,CHPMXW				; Set max # words
]

	HRLZI 1,(GJ%SHT)	;Short GTJFN to get the control channel
	HRROI 2,[ASCIZ \CHA:.FILE\]
	GTJFN
	 ERCAL CTLDON
	HRRZM 1,CTLJFN		;JFN for control channel
	MOVE 2,[100000,,OF%RD\OF%WR]
	OPENF			;Listen for connection
	 ERCAL CTLDON
	MOVEI 2,.MOPKR
	MOVEI 3,CTLPKI
	MTOPR
	 ERCAL CTLDON
	MOVE P,PDL
	PUSHJ P,CHKPVR		;CHECK PROTOCOL VERSION NUMBER
	 JRST CTLDN0		;ALREADY WILL HAVE SENT CLS IF NO GOOD
	MOVE 1,CTLJFN
	MOVEI 2,.MOOPN		;Accept the connection
	MTOPR
	 ERCAL CTLDON
	PUSHJ P,TIMIN1		;Turn on timer interrupts

CTLLOP:	MOVE P,PDL		;For safety, reset the world
	SETZ F,
	SETO A,			;Allow timer interrupts
	EXCH A,TIMINF		;See if timer went off
	SKIPE A
	 PUSHJ P,DWNCHK		;It did, do check now
	MOVE 1,CTLJFN		;Wait for a control packet
	MOVEI 2,.MOPKR
	MOVEI 3,CTLPKI
	MTOPR
	 ERCAL CTLERR		;Flush ourselves if any error
	SETZM TIMINF		;No longer allow timer interrupts
	LDB T,[CTLPKI+$CPKOP]
	CAIL T,%CODAT		;THIS A DATA PACKET?
	 JRST COMMAN		;YES, OK, GO DO A COMMAND FROM IT
	CAIE T,%COEOF		;LISP MACHINE WANT TO CLOSE THE CONNECTION?
         JRST CTLLOP            ;HMMM, BAD PACKET, IGNORE IT FOR NOW
CTLDON:	SKIPG DEBUG		;Dump ourselves
	 JRST CTLDN0
	MOVEM 0,DMPACS
	MOVE 0,[1,,DMPACS+1]
	BLT 0,DMPACS+17
	MOVE 1,[GJ%SHT+GJ%FOU+GJ%NEW]
IFN 20X,HRROI 2,[ASCIZ \PS:<HIC.FILEJOB>DEAD-FILEJOB.EXE\]
IFN 10X,HRROI 2,[ASCIZ \DSK:<CHAOS>DEAD-FILEJOB.SAV\]
	GTJFN
	 JRST CTLDN0
	HRLI 1,.FHSLF
	MOVE 2,[777760,,20]
	SAVE
CTLDN0:	MOVNI 1,1		;-1 means log us out
	SKIPL DEBUG		;If debugging, just stop, will die if top-level
	 LGOUT			;Bye-bye
	 HALTF
	JRST .-1

CTLERR:	MOVEI 1,.FHSLF
	PUSHJ P,$GETER
	 JRST CTLDON		;Punt if no err
	MOVE 1,[441000,,CTLPKO+%CPKDT]
	MOVSI 3,-%CPMXC
	ERSTR
	 JRST CTLDON
	 JFCL
	SETZ BC,
IFN 10X,IDPB BC,1		;Put in null at end
	MOVE 1,[441000,,CTLPKO+%CPKDT]
	ILDB 2,1
	CAIE 2,0
	 AOJA BC,.-2		;Get real size
	MOVEI T,%COLOS		;Send LOS packet
	DPB T,[$CPKOP+CTLPKO]
	DPB BC,[$CPKNB+CTLPKO]
	MOVE 1,CTLJFN
	MOVEI 2,.MOPKS
	MOVEI 3,CTLPKO
	MTOPR
	 ERJMP CTLDON
	JRST CTLDON
]	;END IFN TNX

;;; Called c(D)+1 has code,,pointer-to-asciz-string
COMERR:	MOVEI A,[ASCIZ \ERROR \] ;INDICATE AN ERROR TO THE REQUESTOR
	PUSHJ P,COMCTL
	HLLZ A,1(D)             ;GET ERROR CODE
	PUSHJ P,COMSXO
	MOVEI BYTE,40
	PUSHJ P,COMCHO
	HRRZ A,1(D)             ;NOW OUTPUT THE ERROR STRING
	PUSHJ P,COMSTO
	PUSHJ P,COMSND
	JRST CTLLOP

MINPTC==0
MAXPTC==1

;;; Check protocol version number
CHKPVR:	MOVE BP,[441000,,CTLPKI+%CPKDT]
	LDB BC,[CTLPKI+$CPKNB]
	PUSHJ P,COMRD5		;SHOULD BE FILE
	 TDZA A,A
	PUSHJ P,COMDCI		;GET NUMBER INTO A
	MOVEM A,PTCVER
	CAIL A,MINPTC
	 CAILE A,MAXPTC
	 SKIPA
	 JRST CPOP1J
	MOVEI A,[ASCIZ \PROTOCOL VERSION \]
	PUSHJ P,COMCTL
	MOVE A,PTCVER
	PUSHJ P,COMDCO
	MOVEI A,[ASCIZ \ NOT SUPPORTED\]
	PUSHJ P,COMSTO
	MOVEI T,%COCLS
	JRST COMSN1

;;; Here to handle a command over the control connection
COMBAD:	CERR IRF,[ILLEGAL REQUEST FORMAT]

COMMAN:	MOVE BP,[441000,,CTLPKI+%CPKDT]
	LDB BC,[CTLPKI+$CPKNB]
	PUSHJ P,COMRD5		;Get transaction ID
	 JRST CTLLOP		;Error, ignore this request (what else?)
	MOVEM A,TRANID
	TRZ F,F.FHN             ;NO FILE HANDLE SEEN YET
	MOVEI B,5               ;MAXIMUM FILE-HANDLE SIZE
	SETZ FHN,
	MOVE A,[440700,,FHN]    ;ACCUMULATE FILE HANDLE
COMFHL:	SOJL BC,COMBAD          ;BAD CONTROL PACKET: PROTOCOL VIOLATION
	ILDB BYTE,BP            ;GET THE NEXT CHARACTER
	CAIN BYTE,40            ;SPACE TERMINATES FILE HANDLE
	 JRST COMMA1            ;KEEP PROCESSING
	IDPB BYTE,A
	SOJG B,COMFHL           ;ONLY READ FIRST 5 CHARACTERS
	PUSHJ P,COMEUS          ;EAT UNTIL SPACE SEEN
	 JRST COMBAD            ;NON-SKIP, HIT END OF PACKET OR NEWLINE, ERROR
COMMA1:	JUMPE FHN,COMMA2        ;DON'T HAVE A FILE HANDLE AFTER ALL
	TRO F,F.FHN
	MOVEI IDX,MAXIDX-1      ;LOOP OVER ALL INDICIES
COMMA3:	CAMN FHN,DATFHN(IDX)    ;MATCH?
	 JRST COMMA2            ;YUP, LEAVE IDX IN IDX
	SOJGE IDX,COMMA3
	CERR UFH,[UNKNOWN FILE HANDLE]

COMMA2:	PUSHJ P,COMRD5          ;READ 5 CHARACTERS INTO A
	 JFCL
COMCOM:	JUMPE A,[CERR NCN,[NULL COMMAND NAME]]
	MOVEI T,COMTAL-1        ;COMMAND TABLE LENGTH
COMCO1:	CAMN A,COMTAB(T)        ;MATCH?
	 JRST @COMDSP(T)        ;YES, RUN THE COMMAND
	SOJGE T,COMCO1
	CERR UKC,[UNKNOWN COMMAND]

;;; Command table
COMTAB:	ASCII \DATA-\           ;DATA-CONNECTION
	ASCII \UNDAT\           ;UNDATA-CONNECTION
	ASCII \OPEN\            ;OPEN
	ASCII \CLOSE\           ;CLOSE
	ASCII \FILEP\           ;FILEPOS
	ASCII \DELET\	   	;DELETE
	ASCII \RENAM\	   	;RENAME
	ASCII \CONTI\		;CONTINUE
	ASCII \SET-B\		;SET-BYTE-SIZE
	ASCII \LOGIN\		;LOGIN
	ASCII \DIREC\		;DIRECTORY
	ASCII \COMPL\		;COMPLETE
	ASCII \CHANG\		;CHANGE-PROPERTIES
IFN TNX,ASCII \EXPUN\		;EXPUNGE
COMTAL==.-COMTAB

COMDSP:	COMDCN
	COMUDC
	COMOPN
	COMCLO
	COMFIL
	COMDEL
	COMREN
	COMCON
	COMSBS
	COMLOG
	COMDIR
	COMCPL
	COMCNG
IFN TNX,COMEXP

;;; Subroutines

;Read the next token from the stream.  Reads the first 5 bytes, and throws away the rest.
; Destroys T, TT, and BYTE; result in A.  Tail recurses to COMEUS
COMR10:	MOVEI T,10.		;ALLOW 10 CHARACTERS INTO A AND B
	TDZA B,B
COMRD5:	 MOVEI T,5
	TRZ F,F.NWL
	SETZ A,
	MOVE TT,[440700,,A]     ;ACCUMULATE TOKEN IN A
COMR5A:	SOJL BC,CPOPJ           ;END OF PACKET, HAVE TOKEN
	ILDB BYTE,BP            ;GET THE NEXT CHARACTER
	CAIN BYTE,215           ;NEWLINE TERMINATES
	 JRST COMEUN
	CAIN BYTE,40            ;SPACE TERMINATES THE TOKEN
	 JRST COMEUR
	IDPB BYTE,TT
	SOJG T,COMR5A           ;ONLY READ FIRST 5 CHARACTERS
;	JRST COMEUS	        ;FALL INTO COMEUS

;Eats until end of stream, space, or newline seen
; Non-skip return if end of packet or newline seen, skip return if space seen
COMEUS:	SOJL BC,COMEUP          ;IF END OF STREAM, RETURN
	ILDB BYTE,BP            ;NEXT BYTE
COMEUA:	CAIN BYTE,215           ;NEWLINE
	 JRST COMEUN
	CAIE BYTE,40            ;SPACE
	 JRST COMEUS            ;NOPE, KEEP GOING
COMEUR:	AOS (P)                 ;SKIP RETURN
COMEUP:	TRZA F,F.NWL
COMEUN:	 TRO F,F.NWL
CPOPJ:	POPJ P,

;Single byte output
;Must preserve TT
COMCHO:	CAML BC,CHPMXC
	 CERR TMI,[TOO MUCH INFORMATION]
	IDPB BYTE,BP
	AOJA BC,CPOPJ

;;; For TOPS-20, output from RESBLK, where lots of interesting things get returned
IFN TNX, COMRES: SKIPA A,[440700,,RESBLK]
;String out, string address in A, COMST0 if already byte pointer
COMSTO:	HRLI A,440700           ;MAKE A A STRING POINTER
COMST0:	ILDB BYTE,A             ;GET NEXT CHARACTER
COMST1:	JUMPE BYTE,CPOPJ	;TERMINATE ON NULL
	XCT CHR2LM(BYTE)        ;CONVERT TO LISP MACHINE CHARACTER SET
	 PUSHJ P,COMCHO         ;NON-SKIP, JUST OUTPUT
	 JRST COMST0
	 JRST COMST0		;IGNORE RUBOUT ESCAPE, SHOULDN'T HAPPEN HERE
	MOVEI BYTE,215		;CARRIAGE RETURN, OUTPUT IT
	PUSHJ P,COMCHO
	ILDB BYTE,A		;AND ABSORB FOLLOWING LINE FEED
	CAIN A,12
	 JRST COMST0
	JRST COMST1

;Decimal output, value in A, destroys A and B
COMDCO:	JUMPL A,CPOPJ           ;IGNORE NEGATIVE NUMBERS
	PUSH P,[-1]             ;FLAG BOTTOM OF STACK
COMDO0:	IDIVI A,10.
	PUSH P,B
	JUMPN A,COMDO0
COMDO1:	POP P,BYTE
	JUMPL BYTE,CPOPJ        ;DO UNTIL NO MORE DIGITS
	ADDI BYTE,"0
	PUSHJ P,COMCHO
	JRST COMDO1

;Sixbit output, sixbit in A, destroys A and B.  Quotes funny characters.
COMSXO:	MOVE B,A
COMSO0:	JUMPE B,CPOPJ           ;TERMINATE WHEN NO MORE BYTES
	SETZ A,
	LSHC A,6                ;GET NEXT BYTE
	JUMPE A,COMSOQ		;QUOTE LEADING SPACES
	CAIE A,':		;AND : OR ;
	 CAIN A,';
	 JRST COMSOQ
COMSO1:	MOVEI BYTE,40(A)        ;MAKE ASCII
	PUSHJ P,COMCHO          ;OUTPUT THE BYTE
	JRST COMSO0

COMSOQ:	MOVEI BYTE,"
	PUSHJ P,COMCHO
	JRST COMSO1

;Output date/time from A
COMDTO:
IFN TNX,[
;; Internal date/time in A -- convert ot ITS format
	MOVE 2,A
	AOSN A			;If -1, then use 0
	 SETZ 2,
	SETZ 4,
	ODCNV			;Convert internal date/time to printable format
	 ERJMP JSYSER
	HRRZ A,4		;Local time in seconds
	LSH A,1			;Number of half-seconds since midnight
	HLRZ T,2		;The year
	SUBI T,1900.
	DPB T,[330700,,A]
	AOS 2
	DPB 2,[270400,,A]	;The month
	HLRZ T,3		;The day
	AOS T
	DPB T,[220500,,A]
]	;END IFN TNX
IFN ITS,[
	CAMN A,[-1]
	MOVEI A,0
]
	PUSH P,A
	LDB A,[270400,,0 (P)]	;MONTH  3.9-3.6
	IDIVI A,10.
	MOVEI BYTE,"0(A)
	PUSHJ P,COMCHO
	MOVEI BYTE,"0(B)
	PUSHJ P,COMCHO
	MOVEI BYTE,"/
	PUSHJ P,COMCHO
	LDB A,[220500,,0 (P)]	;DAY  3.5-3.1
	IDIVI A,10.
	MOVEI BYTE,"0(A)
	PUSHJ P,COMCHO
	MOVEI BYTE,"0(B)
	PUSHJ P,COMCHO
	MOVEI BYTE,"/
	PUSHJ P,COMCHO
	LDB A,[330700,,0 (P)]	;YEAR  4.7-4.1
	IDIVI A,100.
	EXCH A,B
	JUMPE B,.+3
	MOVEI BYTE,"0(B)
	PUSHJ P,COMCHO
	IDIVI A,10.
	MOVEI BYTE,"0(A)
	PUSHJ P,COMCHO
	MOVEI BYTE,"0(B)
	PUSHJ P,COMCHO
	MOVEI BYTE,40
	PUSHJ P,COMCHO
	HRRZ A,(P)              ;TIME
	LSH A,-1		;Half-seconds since midnight, HOW RANDOM!
	IDIVI A,60.		;Get number of seconds
	PUSH P,B		;Save them
	IDIVI A,60.		;Get number of minutes
	PUSH P,B		;Save them
REPEAT 3,[			;Output each of the sections with intervening colons
	IDIVI A,10.
	MOVEI BYTE,"0(A)
	PUSHJ P,COMCHO
	MOVEI BYTE,"0(B)
	PUSHJ P,COMCHO
IFN .RPCNT-2,[
	MOVEI BYTE,":
	PUSHJ P,COMCHO
	POP P,A
]	;End IFN
]	;End REPEAT
	POP P,A
	POPJ P,

;Setup for returning a control packet
COMCTL:	MOVE BP,[441000,,%CPKDT]
	ADD BP,PKTLOC
	SETZ BC,
	PUSH P,A
	MOVEI A,TRANID		;Get current transaction ID
	PUSHJ P,COMSTO		;This heads all replies
	MOVEI BYTE,40
	PUSHJ P,COMCHO
	TRNN F,F.FHN            ;FILE HANDLE?
	 JRST COMCT0
	MOVE A,DATFHN(IDX)      ;YES, GET THE FILE HANDLE
	MOVEM A,FHNOUT
	MOVEI A,FHNOUT          ;AND LEAD WITH IT
	PUSHJ P,COMSTO
COMCT0:	POP P,A
	MOVEI BYTE,40
	PUSHJ P,COMCHO          ;LEADING SPACE
	JRST COMSTO             ;OUTPUT THE APPROPRIATE COMMAND AND RETURN

;Send or expect synchronous mark.  For output files, A is pointer to routine to be run
; when mark arrives.  NOTE: this routine will not work recursivly
COMSSY:
IFN ITS,[
	.SUSET [.SPICLR,,[0]]   ;To prevent timing screws, turn off all interrupts
]	;END IFN ITS
IFN TNX,[
	MOVEI 1,.FHSLF		;Disable interrupts temporarily to prevent timing lossage
	DIR
]	;END IFN TNX
	MOVE T,DATSTA(IDX)
	TLO T,ST.SYN            ;Send synchronous mark
	JRST @SSYDSP(T)         ;Dispatch on current state

SSYDSP:	SSYCLO                  ;Closed
	SSYOPN                  ;Open
	SSYASY                  ;Async marked
	SSYSYN                  ;Sync marked
	SSYEOF                  ;EOF state

;Sync marked state means that the mark has arrived already.  Run the routine here and now.
; A gets replaced with the channel status
SSYSYN:	EXCH T,A                ;Meanings are reversed
	TLZ A,ST.SYN            ;No longer marked
IFN ITS,[
	.SUSET [.SDF2,,[-1]]    ;Defer all channel interrupts
	.SUSET [.SPICLR,,[-1]]  ;Reenable things like IOC et al	
]	;END IFN ITS
	PUSHJ P,(T)	        ;Call routine
	MOVEM A,DATSTA(IDX)     ;May have changed channel state
IFN TNX,[
;; Since on Tops-20 there is no way to defer only a certain set of interrupts, they
;; will all be left defered.  This is a total loss.
	MOVEI 1,.FHSLF		;Turn interrupt back on
	EIR
	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	AIC			;Reenable interrupts on this channel
;	MOVEI 1,.FHSLF
;	MOVE 2,CHABIT(IDX)
	IIC			;Force interrupt on channel to start ball rolling
]	;END IFN TNX
IFN ITS,[
	.SUSET [.SDF2,,SSYDF2]  ;Restore old DF2 value
	MOVE T,CHABIT(IDX)
	TRNN IDX,1	        ;This an output idx?
	 JRST SSYSY0		;Nope, need to cause interrupt to get ball rolling
	ANDCAM T,SSYDF2		;This interrupt is no longer deffered
	.SUSET [.SDF2,,SSYDF2]
;;; NOTE: Due to the fact that some packets may be sitting in the buffers but not
;;; interrupting (if we dismissed the interrupt with packets lying around), we
;;; better cause an interrupt to let them get processed
SSYSY0:	.SUSET [.SIIFPIR,,T]
]	;END IFN ITS
	POPJ P,

;Closed or in EOF state
SSYCLO:
SSYEOF:	TRNN IDX,1		;An input channel?
	 JRST SSYAS0		;Yes, cause an interrupt to get the ball rolling
	JRST SSYOPN

;Async marked means that interrupts (for output channels) have been deffered.
SSYASY:
IFN ITS,[
	TRNN IDX,1		;This an output channel?
	 JRST SSYAS0		;Nope, so no need to undefer
	MOVE TT,CHABIT(IDX)	;Get mask bit
	ANDCAM TT,SSYDF2	;Undefer
	.SUSET [.SDF2,,SSYDF2]

SSYAS0:	MOVE TT,CHABIT(IDX)
	.SUSET [.SIIFPIR,,TT]	;Cause interrupt to happen right now
]	;END IFN ITS
IFN TNX,[
	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	AIC			;Reenable interrupts on this channel
SSYAS0:	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	IIC			;Force interrupt on channel to start ball rolling
]	;END IFN TNX
;	JRST SSYOPN		;Fall into SSYOPN

;Open just needs to set bit
SSYOPN:	MOVEM T,DATSTA(IDX)
	MOVEM A,DATSYA(IDX)	;A is pointer to action to be taken upon receipt/transmission
IFN ITS,[
	.SUSET [.SPICLR,,[-1]]  ;Reenable the world
]	;END IFN ITS
IFN TNX,[
	MOVEI 1,.FHSLF
	EIR			;Turn the interrupt system back on
]	;END IFN TNX
	POPJ P,

;;; Send the control packet that has been built in CTLPKO
COMSND:	MOVEI T,CO%TXT
COMSN1:	DPB T,[$CPKOP+CTLPKO]
	DPB BC,[$CPKNB+CTLPKO]
IFN ITS,[
	.CALL [	SETZ
		SIXBIT /PKTIOT/
		%CLIMM,,CTRLO
		%CLIMM+%CLEND,,CTLPKO]
	 .LOSE %LSSYS
	POPJ P,
]	;END IFN ITS
IFN TNX,[
	MOVE 1,CTLJFN
	MOVEI 2,.MOPKS
	MOVEI 3,CTLPKO
	MTOPR
	 ERCAL CTLERR
	POPJ P,
]	;END IFN TNX

IFN ITS,[
;File name reader.  Returns in DAT???(IDX)
COMPFN:	MOVSI TT,'DSK		;Default device is DSK
	MOVEM TT,DATDEV(IDX)
	SETZM DATFN1(IDX)       ;No default FN1
	TRZ F,F.FN1+F.FN2+F.DEV+F.DIR
COMPF0:	PUSHJ P,COMSYL          ;Read next sixbit frob, BYTE has terminator
	CAIN BYTE,":
	 JRST [ MOVEM A,DATDEV(IDX) ? JRST COMPF0 ]
	CAIN BYTE,";
	 JRST [ MOVEM A,DATSNM(IDX) ? JRST COMPF0 ]
	JUMPE A,COMPF1
	TRON F,F.FN1
	 JRST [ MOVEM A,DATFN1(IDX) ? JRST COMPF1 ]
	TRON F,F.FN2
	 JRST [ MOVEM A,DATFN2(IDX) ? JRST COMPF1 ]
	TRON F,F.DEV
	 JRST [ MOVEM A,DATDEV(IDX) ? JRST COMPF1 ]
	TRON F,F.DIR
	 JRST [ MOVEM A,DATSNM(IDX) ? JRST COMPF1 ]
COMPF1:	CAIN BYTE,215           ;Terminate on newline
	 JRST COMEUN
	JRST COMPF0
]	;END IFN ITS

IFN TNX,[
COMGJF:	MOVE 2,BP		;Source of filename
	PUSHJ P,COMEUS		;Find end of filename
	 JRST [TRZN F,F.NWL	;Must be terminated with a newline
	        JRST COMBAD
	       JRST .+2]
	  JRST .-2		;Terminated by space, so keep searching
	SETZ 1,
	DPB 1,BP		;Insure terminating NULL
	MOVE 1,[GJ%SHT+.GJDEF]	;Setup flags to GTJFN
	TLNE D,ST.OUT		;Output idx?
	 TLOA 1,(GJ%FOU\GJ%NEW)	;Use next generation number, must be new file
				; (probably redundant)
	  TLO 1,(GJ%OLD)	;Must be an old file
	TLNE D,ST.DIR
	 JRST [	TLO 1,(GJ%IFG)
		JRST COMGJ1]	;Allow wild cards for directory
	TLNE D,ST.TEM		;Temporary file?
	 TLO 1,(GJ%TMP)
COMGJ1:	TLNE D,ST.DEL		;Permit deleted file?
	 TLO 1,(GJ%DEL)
	TLNE D,ST.PON
	 JRST [	TLO 1,(GJ%OFG)
		TLZ 1,(GJ%OLD)
		JRST .+1]	;Parse only if so desired
	GTJFN
	 POPJ P,		;JSYS error, return it to user
	AOS (P)
	POPJ P,
]	;END IFN TNX

;Read a syllable
COMSYL:	SETZ A,
	MOVE TT,[440600,,A]
COMSY3:	SOJL BC,COMBAD          ;If no more bytes then done
	ILDB BYTE,BP
	CAIE BYTE,^Q
	 JRST COMSY1            ;Not quoted char
	SOJL BC,COMBAD
	ILDB BYTE,BP
	JRST COMSY2

COMSY1:	CAIE BYTE,":            ;Colon, semicolon and space and control chars end syllable
	 CAIN BYTE,";
	  JRST CPOPJ
	CAIN BYTE,215
	 JRST COMEUN
	CAIG BYTE,40
	 JRST CPOPJ
COMSY2:	CAIGE BYTE,40		;CONTROL CHARS END SYLLABLE EVEN IF ^Q'D.
	 POPJ P,
	CAIGE BYTE,140		;SKIP IF "LOWER CASE"
	 SUBI BYTE,40
	TLNE TT,770000
	 IDPB BYTE,TT
	JRST COMSY3

COMSY0:	MOVEI BYTE,215          ;Fudge EOL
	POPJ P,

;;; Decimal number reader
COMDCI:	MOVEI T,10.		;Read in BASE 10
COMNUI:	SETZ A,
COMNU0:	SOJL BC,CPOPJ
	ILDB BYTE,BP
	CAIL BYTE,"0
	 CAIL BYTE,"0(T)
	  JRST COMEUA
	IMULI A,(T)
	ADDI A,-"0(BYTE)
	JRST COMNU0

;;; Sixbit input
COMSXI:	MOVEI T,6.		;Maximum of 6 chars
	MOVE TT,[440600,,A]	;Collect in A
	SETZ A,
COMSI0:	SOJL BC,CPOPJ		;Return if nothing more to read
	ILDB BYTE,BP
	CAIL BYTE,"a
	 CAILE BYTE,"z
	  SKIPA
	   SUBI BYTE,"a-"A
	SUBI BYTE,40		;Convert to sixbit
	JUMPL BYTE,CPOPJ	;Return if it's a non-sixbit character
	CAILE BYTE,77
	 POPJ P,
	SOJL T,COMSI0		;Don't stick in if no more room
	IDPB BYTE,TT
	JRST COMSI0

;;; Date input
IFN ITS,[			;This only allows MM/DD/YY HH:MM:SS
COMDTI:	SETZ A,
	PUSHJ P,COMDT1
	DPB T,[270400,,A]	;Month 3.9-3.6
	PUSHJ P,COMDT1
	DPB T,[220500,,A]	;Day 3.5-3.1
	PUSHJ P,COMDT1
	DPB T,[330700,,A]	;Year 4.7-4.1
	CAIN BYTE,215		;If no newline, then no time
	 JRST COMEUN
	PUSHJ P,COMDT1		;Hours
	MOVE B,T
	PUSHJ P,COMDT1		;Minutes
	IMULI B,60.
	ADD B,T
	PUSHJ P,COMDT1		;Seconds
	IMULI B,60.
	ADD B,T
	LSH B,1			;Half seconds
	HRR A,B
	POPJ P,

COMDT1:	SETZ T,
COMDT2:	SOJL BC,CPOPJ
	ILDB BYTE,BP
	CAIL BYTE,"0
	 CAILE BYTE,"9
	 POPJ P,
	IMULI T,10.
	ADDI T,-"0(BYTE)
	JRST COMDT2
]	;END IFN ITS

IFN TNX,[
COMDTI:	MOVE 1,BP		;Source of date
	PUSHJ P,COMEUS		;Find end
	 JRST [TRZN F,F.NWL	;Must be terminated with a newline
	        JRST COMBAD
	       JRST .+2]
	  JRST .-2		;Terminated by space, so keep searching
	SETZ 2,
	DPB 2,BP		;Insure terminating NULL
	IDTIM
	 ERJMP JSYSER
	MOVE A,2
	POPJ P,
]	;END IFN TNX

;;; Create a new data connection
COMDCN:	TRZN F,F.FHN            ;MUST NOT HAVE A FILE HANDLE
	 TRZE F,F.NWL           ;NEWLINE TERMINATES COMMAND?
	  JRST COMBAD           ;ILLEGAL REQUEST FORMAT
	PUSHJ P,COMRD5          ;READ THE NEXT TOKEN, WHICH SHOULD BE THE INPUT FILE HANDLE
	 JRST COMBAD
	PUSH P,A                ;SAVE ON STACK
	PUSHJ P,COMRD5          ;NEXT TOKEN AS WELL
	 TRZE F,F.NWL           ;BETTER HAVE GOTTEN TO END OF PACKET
	  JRST COMBAD           ;NOT END OF PACKET, BUT DIDN'T WANT ANY MORE CRUFT
	MOVEI IDX,MAXIDX-2      ;CHECK FOR A FREE DATA CONNECTION
COMDC2:	SKIPN DATFHN(IDX)       ;BOTH FILE HANDLE'S NULL MEANS A FREE ONE
	 SKIPE DATFHN+1(IDX)
	  JRST COMDC1           ;NOT FREE, CONTINUE SEARCHING
	MOVEM A,DATFHN+1(IDX)   ;OUTPUT FILE HANDLE
	POP P,DATFHN(IDX)       ;AND INPUT FILE HANDLE
	MOVEM A,FHNOUT          ;FILE HANDLE TO RFC TO: USE THE OUTPUT SIDE
IFN ITS,[
	.CALL [	SETZ
		SIXBIT /CHAOSO/
		%CLIN,,CHACHN+1(IDX)
		%CLIN,,CHACHN(IDX)
		%CLIMM+%CLEND,,15.]
	 JRST [	SETZM DATFHN(IDX)	;IDX's not really in use
		SETZM DATFHN+1(IDX)
		JRST COMNER]
	MOVEI A,FHNOUT          ;POINT TO IT
	SETZ BC,
	MOVE BP,[441000,,CTLPKO+%CPKDT]
	PUSHJ P,COMSTO          ;STRING-OUT TO PACKET, POINTER TO STRING IN A
	MOVEI T,%CORFC
	DPB T,[CTLPKO+$CPKOP]   ;RFC
	DPB BC,[CTLPKO+$CPKNB]  ;NUMBER OF BYTES
	LDB T,[CTLPKI+$CPKSA]
	DPB T,[CTLPKO+$CPKDA]
	.CALL [	SETZ
		SIXBIT /PKTIOT/
		%CLIN,,CHACHN(IDX)
		%CLIMM+%CLEND,,CTLPKO]
	 .LOSE %LSSYS
	MOVE T,CHABIT(IDX)	;Get input channel bit
	IOR T,CHABIT+1(IDX)	;And output channel bit
	.SUSET [.SIMSK2,,T]	;Enable interrupts on these channels
]	;END IFN ITS
IFN TNX,[
	HRROI 1,JFNSTR		;Build output string
	HRROI 2,[ASCIZ \CHA:\]
	SETZB 3,4
	SOUT
	 ERJMP JSYSER
	LDB 2,[CTLPKI+$CPKSA]	;Source address
	MOVEI 3,8.
	NOUT
	 ERJMP JSYSER
	MOVEI 2,".
	IDPB 2,1
	HRROI 2,FHNOUT
	SOUT			;Now have:  CHA:<host>.<contact name>
	 ERJMP JSYSER
	HRLZI 1,(GJ%SHT)	;Short GTJFN to get the channel
	HRROI 2,JFNSTR
	GTJFN
	 ERJMP JSYSER
	HRRZM 1,CHAJFN(IDX)	;This is this idx's input and output JFN
	HRRZM 1,CHAJFN+1(IDX)
	MOVE 2,[100000,,OF%RD\OF%WR]
	OPENF			;Listen for connection
	 ERJMP JSYSER
	MOVE 1,CHAJFN(IDX)	;Set input window size
	MOVEI 2,.MOSWS
	MOVEI 3,15
	MTOPR
	 ERJMP JSYSER
	MOVE 1,CHAJFN(IDX)	;Assign interrupt channel
	MOVEI 2,.MOACN
	MOVE 3,IDX
	LSH 3,-1
	MOVE 3,CHAICN(3)	;Output,,Input channels
	MTOPR
	 ERJMP JSYSER
	MOVEI 1,.FHSLF		;Activate the interrupt channel
	MOVE 2,CHABIT(IDX)
	AIC
]	;END IFN TNX
	MOVEI A,[ASCIZ \DATA-CONNECTION\]
	PUSHJ P,COMCTL          ;SEND RESPONSE
	PUSHJ P,COMSND          ;SEND THE CONTROL PACKET
	JRST CTLLOP             ;RETURN TO MAIN CONTROL CONNECTION WAIT

COMDC1:	SUBI IDX,2
	JUMPGE IDX,COMDC2       ;LOOP IF MORE CHANNELS TO CHECK
COMNER:	CERR NER,[NOT ENOUGH RESOURCES]

;;; Destroys a data connection
COMUDC:	TRNE F,F.FHN            ;Must have a file handle
	 TRZE F,F.NWL           ;Not terminated by newline
	  JRST COMBAD
	JUMPGE BC,COMBAD	;But that's all there is
	TRO IDX,1               ;Point to top of two channel pair
	SKIPGE DATSTA(IDX)      ;Channel active?
	 PUSHJ P,CLOSIT		;Yes, close it
	SETZM DATSTA(IDX)	;Make sure channel is deactivated
	TRZ IDX,1               ;Now point to bottom of pair
	SKIPGE DATSTA(IDX)      ;What about this on.  Is it active?
	 PUSHJ P,CLOSIT		;Yes, close it
	SETZM DATSTA(IDX)	;Make sure channel is deactivated
	MOVEI A,[ASCIZ \UNDATA-CONNECTION\]
	PUSHJ P,COMCTL          ;Setup control packet
	PUSHJ P,CHNFLS		;Flush the chaos channels
	PUSHJ P,COMSND          ;Send it
	JRST CTLLOP             ;Return to main loop


;;; Flush chaos net channels pointed to by IDX.  IDX assumed to point
;;; to the input (even) side.
CHNFLS:
IFN ITS,[
	MOVE T,CHABIT(IDX)
	IOR T,CHABIT+1(IDX)
	.SUSET [.SAMSK2,,T]	;Turn off interrupts for the two chaos channels of interest
	.CALL [ SETZ
		SIXBIT /CLOSE/  ;Close the chaos channels
		%CLIN+%CLEND,,CHACHN(IDX)]
	 .LOSE %LSSYS
	.CALL [ SETZ
		SIXBIT /CLOSE/
		%CLIN+%CLEND,,CHACHN+1(IDX)]
	 .LOSE %LSSYS
]	;END IFN ITS
IFN TNX,[
	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	DIC			;Disable the interrupt channel
	HRRZ 1,CHAJFN(IDX)	;Close and release JFN
	CLOSF
	 JFCL
]	;END IFN TNX
	SETZM DATFHN(IDX)       ;Make this pair available for a new data connection
	SETZM DATFHN+1(IDX)
	POPJ P,

;;; LOGIN command
COMLOG:	TRZN F,F.FHN		;No file handle
	 TRZE F,F.NWL		;No newline
	  JRST COMBAD
IFN ITS,[
	PUSHJ P,COMSXI		;Read user id in sixbit
	MOVEM A,USERID		;Remember for later
	MOVEI A,[ASCIZ \LOGIN \]
	PUSHJ P,COMCTL
	SKIPE A,USERID
	 PUSHJ P,GETNAM		;Output uname, hsname and personal name
]	;END IFN ITS
IFN TNX,[
	JUMPLE BC,CTLDN0	;Really logout if no arguments
	MOVE 2,BP		;Save copy of byte pointer
	PUSHJ P,COMEUS		;Eat until space, newline, or end
	JUMPL BC,COMBAD		;End of packet is no good
	SETZ T,			;Deposit null to terminate string
	DPB T,BP
	MOVSI 1,(RC%EMO)	;Exact match
	RCUSR
	TLNE 1,(RC%NOM)		;Matched?
	 CERR UNK,[USER NOT KNOWN]
	MOVEM 3,USRNUM		;Save user number
IFN 20X,[
	MOVEI 1,.SFCHA		;See if Chaosnet checking is on
	TMON
	 ERJMP COMLG1		;Not even implemented - skip check
	JUMPE 2,COMLG1		;It's off - skip the check
	MOVEI 1,.FHSLF		;Must enable for GTDIR
	RPCAP
	MOVE 3,2
	EPCAP
	MOVEI 1,0
	MOVE 2,USRNUM
	RCDIR			;Get dir number
	MOVE 1,3
	MOVEI 2,DIRINF		;Discover user's capabilities
	MOVEI 3,0
	SETZM DIRINF
	GTDIR
	 ERJMP JSYSER
	MOVE 1,DIRINF+.CDPRV	;Check for Chaos net privilege
	TRNN 1,SC%CHA
	 CERR NCP,[NO CHAOSNET PRIVILEGES]
COMLG1:
]	;END IFN 20X
	MOVE 2,BP		;Beginning of password string	
	ILDB 3,2		;Get and save first char
	TRZ F,F.ENA
	CAIN 3,"*		;Is first letter * ?
	 TROA F,F.ENA		;Enable
	  SKIPA 2,BP		;Remember unbumped version
	   MOVE BP,2		;Update BP to skip *
	PUSHJ P,COMEUS		;Find next terminating character
	 JFCL
	SETZ T,
	DPB T,BP		;Terminate password with null byte
	MOVE 3,BP		;This is account string
	PUSHJ P,COMEUS		;Then find end of string
	 JUMPGE BC,COMBAD
	SETZ T,
	DPB T,BP		;Terminate with null byte
	IDPB T,BP		;In case no acct string given
	MOVE T,3
	ILDB T,T
IFN 20X,[
	SKIPN T
	 SETZ 3,		;Use default if empty string
];20X
IFN 10X,[
	JUMPN T,COMLG3
	PUSH P,2		;Save password string
	MOVEI 1,DIRINF		;Where to put account designator if string
	MOVE 2,USRNUM
	JSYS 331		;GDACC
	 SETZ 1,		;Doesn't seem to have a default, will get error
	MOVE 3,1		;Number or byte pointer
	POP P,2			;Get back password
COMLG3:
];10X
	SKIPGE DEBUG
	 JRST COMLG2		;If debugging, don't do real login, or enable
	MOVE 1,USRNUM
	LOGIN			;Login with specified parameters
	 JRST JSYSER
	TRZN F,F.ENA
	 JRST COMLG2
	MOVEI 1,.FHSLF
	RPCAP
	MOVE 3,2
	EPCAP
COMLG2:	MOVE 1,[SIXBIT /FILE/]
	SETNM			;Make us print nicely
	SETOM USERID		;Means we are logged in
	MOVEI A,[ASCIZ \LOGIN \]	;Success reply
	PUSHJ P,COMCTL
	PUSHJ P,GETNAM
]	;END IFN TNX
	PUSHJ P,COMSND		;Completion reply
	JRST CTLLOP		;Then we are done

IFN ITS,[
;;; INQUIR hacking
$$ULNM==0
$$ULNP==0
$$UNAM==0
$$HSNM==1

LSRTNS"E==T
LSRPGS==200			;Pages for LSRTNS hacking
NLSPGS==20			;Reserve 20 of them

.INSRT SYSENG;LSRTNS >

;;; Output UNAME<SP>HSNAME<NL>PERNAM<NL>
GETNAM:	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSH P,A
	MOVEI A,UTILCH		;Channel for LSRTNS
	MOVE B,[-NLSPGS,,LSRPGS]
	PUSHJ P,LSRTNS"LSRMAP
	 JRST COMNER		;Random error
	MOVEI A,UTILCH		;Channels for INQUIR database
	MOVE B,(P)
	SETZ C,			;Local host
	MOVEI D,ERRCH
	PUSHJ P,LSRTNS"LSRUNM	;Map in the LSRTNS entry
	 JRST [	SETZ B,		;No entry there
		MOVE A,(P)	;UNAME
		PUSHJ P,COMSXO
		MOVE A,[440700,,[ASCII \???  \ ? 0 ? 0]]
		JRST GETNM1]	;And go compute HSNAME
	MOVEI A,1(B)
	PUSHJ P,COMSTO
GETNM1:	MOVEI BYTE," 
	PUSHJ P,COMCHO
	EXCH A,(P)		;Get UNAME, save string of personal name
	PUSHJ P,LSRTNS"LSRHSN	;Convert to HSNAME
	 JFCL
	MOVE A,D		;Get answer
	MOVEM A,HSNAME
	PUSHJ P,COMSXO
	MOVEI BYTE,215		;NL
	PUSHJ P,COMCHO
	POP P,A			;Get back pointer to personal name
	PUSHJ P,COMST0
	MOVEI BYTE,215
	PUSHJ P,COMCHO
	MOVEI B,LSRTNS"I$GRP-LSRTNS"I$NAME-1	;Skip up to group affiliation
	ILDB BYTE,A
	JUMPN BYTE,.-1
	SOJG B,.-2
	PUSHJ P,COMST0
UNMAPL:	MOVE B,[-NLSPGS,,LSRPGS]
	.CALL [	SETZ		;Done with these
		SIXBIT /CORBLK/
		%CLIMM,,0
	       	%CLIMM,,%JSELF
		SETZ B]
	 JFCL
	.CLOSE UTILCH,
	.CLOSE ERRCH,
	POP P,D
	POP P,C
	POP P,B
	POPJ P,
]	;END IFN ITS

IFN TNX,[
;;; INQUIR hacking
;;; Output USERNAME<SP>DIRECTORY<NL>PERSONAL NAME<NL>
GETNAM:	HRROI 1,RESBLK
	MOVE 2,USRNUM
	DIRST
	 JFCL
	MOVEI 2,0
	IDPB 2,1
	PUSHJ P,COMRES		;Output user name
	MOVEI BYTE,40
	PUSHJ P,COMCHO
	MOVSI 1,(GJ%OLD\GJ%SHT)
IFN 20X,HRROI 2,[ASCIZ /SYS:PEOPLE.DATA/]
IFN 10X,HRROI 2,[ASCIZ /<INQUIR>PEOPLE.DATA/]
	PUSH P,[0]
	GTJFN
	 JRST GETNM3
	MOVEM 1,(P)		;Save jfn
	MOVE 2,[440000,,OF%RD]
	OPENF
	 JRST GETNM3
	HRRZ 3,USRNUM
	RIN
	JUMPE 2,GETNM3		;No information on this user
	HLRZ 3,2
	HRRZS 2
	SFPTR
	 JRST GETNM3
	CAILE 3,INQBLL
	 MOVEI 3,INQBLL
	MOVN 3,3
	MOVE 2,[444400,,INQBLK]
	SIN			;Get all data on the person
	MOVE A,[440600,,INQBLK+1]	;Byte counts
	MOVE B,[440700,,INQBLK+4]	;String starts
	MOVEI C,2		;Want two fields
GETNM0:	ILDB T,A		;Get byte count
GETNM1:	ILDB BYTE,B		;Get a character
	PUSHJ P,COMCHO		;Output it
	SOJG T,GETNM1
	MOVEI BYTE,215
	PUSHJ P,COMCHO		;Output newline
	SOJG C,GETNM0
GETNM2:	POP P,1
	JUMPE 1,.+3
	CLOSF
	 RLJFN
	 JFCL
	POPJ P,

;;; No INQUIR information
GETNM3:	HRROI 1,RESBLK
	MOVE 2,USRNUM
IFN 20X,TLO 2,40000
	DIRST
	 JFCL
	PUSHJ P,COMRES
	MOVEI BYTE,215
	PUSHJ P,COMCHO
	MOVEI A,[ASCIZ /???/]
	PUSHJ P,COMSTO
	MOVEI BYTE,215
	PUSHJ P,COMCHO
	JRST GETNM2
];IFN TNX

;;; Open a file
COMOPN:	SKIPN USERID		;Has the user logged in?
	 CERR NLI,[NOT LOGGED IN]
	TRZ F,F.PRB\F.DEF
	TRNN F,F.FHN            ;MUST HAVE A FILE HANDLE FOR NORMAL OPEN
	 JRST OPNPRB            ;ELSE MUST BE A PROBE
	SKIPGE DATSTA(IDX)      ;THIS CHANNEL CURRENTLY ACTIVE?
	 PUSHJ P,CLOSIT		;YES, CLOSE IT
OPNPR0:	SETZB D,DATSTA(IDX)     ;START OUT FRESH, D WILL CONTAIN NEW LH OF DATSTA
	MOVEI T,16.             ;DEFAULT DATBYT
	MOVEM T,DATBYT(IDX)
	MOVEI T,2.		;NUMBER OF BYTES PER WORD
	MOVEM T,DATBPW(IDX)
OPNOPT:	TRNE F,F.NWL            ;NEW LINE TERMINATED OPEN COMMAND?
	 JRST OPNFNM            ;YES, DEFAULT OPTIONS, PARSE FILENAME
	PUSHJ P,COMRD5          ;GET NEXT TOKEN
	 JUMPL BC,COMBAD
OPNOLP:	MOVEI T,OPNLEN-1        ;LENGTH OF OPEN OPTION TABLE
OPNOL1:	CAME A,OPNTAB(T)        ;MATCH?
	 SOJGE T,OPNOL1         ;NOPE, KEEP ON
	JUMPL T,[CERR UOO,[UNKNOWN OPEN OPTION]]
	XCT OPNACT(T)           ;PERFORM APPROPRIATE ACTION
	 JRST COMBAD            ;ERROR
	JRST OPNOPT

OPNTAB:	ASCII \READ\		;Read
	ASCII \WRITE\		;Write
	ASCII \PROBE\		;Probe
	ASCII \CHARA\		;Character mode
	ASCII \BINAR\		;Binary mode
	ASCII \DEFAU\		;Default mode
	ASCII \BYTE-\		;Byte size specification
	ASCII \RAW\		;Raw mode (the bytes as they come)
	ASCII \SUPER\		;Super-image -- don't treat rubouts specially
	ASCII \PRESE\		;Preserve-dates
IFN TNX,[
	ASCII \TEMPO\		;Temporary file
	ASCII \DELET\		;Deleted files are ok
]	;END IFN TNX
OPNLEN==.-OPNTAB

OPNACT:	TRNE IDX,1
	TRNN IDX,1
	TROA F,F.PRB
	TLZA D,ST.BIN
	TLOA D,ST.BIN
	JRST [	TRO F,F.DEF
		TLO D,ST.BIN
		JRST OPNOPT]
	JRST OPNBYS
	TLOA D,ST.RAW
	TLOA D,ST.SUI
	TLOA D,ST.PDT
IFN TNX,[
	TLOA D,ST.TEM
	TLOA D,ST.DEL
]	;END IFN TNX

OPNBYS:	TRNE F,F.NWL            ;BETTER NOT HAVE A NEWLINE
	 JRST COMBAD
	PUSHJ P,COMDCI          ;READ A NUMBER FROM THE STREAM
	 JUMPL BC,COMBAD        ;MUST HAVE STUFF LEFT
	SKIPLE A                ;BYTE-SIZE MUST BE BETWEEN 0 AND 16.
	 CAILE A,16.
	  CERR IBS,[ILLEGAL BYTE SIZE]
	MOVEM A,DATBYT(IDX)     ;SAVE THE BYTE SIZE
	MOVE B,A
	MOVEI A,36.
	IDIV A,B
	MOVEM A,DATBPW(IDX)	;REMEMBER BYTES PER WORD
	JRST OPNOPT             ;AND CONTINUE

OPNPRB:	MOVEI IDX,MAXIDX        ;SPECIAL PROBE INDEX
	TRO F,F.PRB             ;DOING A PROBE
	TRNN F,F.NWL            ;IF NO OPTIONS, THAT'S OK
	 JRST OPNPR0		;Now process options

OPNFNM:	HLLM D,DATSTA(IDX)
IFN ITS,[
	PUSHJ P,COMPFN          ;PARSE THE FILENAME
	TRNE IDX,1              ;OUTPUT INDEX?
	 JRST OPNOUT            ;YES, HAS TO HAPPEN SOMEWHAT DIFFERENTLY
	MOVEI T,.UAI            ;ASSUME TEXT MODE
	TLNE D,ST.BIN           ;UNLESS REALLY BINARY
	 MOVEI T,.UII
	TLNE D,ST.PDT
	 TRO T,10
	.CALL [ SETZ
		SIXBIT /OPEN/
		%CLERR,,ERRCOD
		%CLBTW,,T       ;Appropriate mode
		%CLIN,,DATCHN(IDX)
		%CLIN,,DATDEV(IDX)
		%CLIN,,DATFN1(IDX)
		%CLIN,,DATFN2(IDX)
		%CLIN+%CLEND,,DATSNM(IDX)]
	 JRST OPNERR
	.CALL [ SETZ            ;GET TRUENAME TO RETURN TO USER
		SIXBIT /RFNAME/
		%CLIN,,DATCHN(IDX)
		%CLOUT,,DATDEV(IDX)
		%CLOUT,,DATFN1(IDX)
		%CLOUT,,DATFN2(IDX)
		%CLOUT+%CLEND,,DATSNM(IDX)]
	 JFCL                   ;WELL, IT SHOULDN'T BUT...
	TLNN D,ST.BIN		;Don't try to QFASLP for text files
	 JRST OPNFN0
	MOVEI T,1               ;READ THE FIRST WORD OF THE FILE FOR QFASLP
	MOVE TT,[444400,,B]     ;ONE BYTE INTO B
	.CALL [ SETZ
		SIXBIT /SIOT/
		%CLIN,,DATCHN(IDX)
		%CLIN,,TT
		%CLIN+%CLEND,,T]
	 SETZ B,                ;HMMM....
	CAMN B,[SIXBIT /QFASL/] ;A QFASL FILE?
	 TROA F,F.QFP		;YES
	 JRST [	TRNN F,F.DEF	;CHARACTERS DEFAULT?
		 JRST .+1	;NO
		TLZ D,ST.BIN	;YES, NOT BINARY THEN
		HLLM D,DATSTA(IDX)
		TRNE F,F.PRB
		 JRST .+1
		JRST OPNACF]	;And need to reopen in case it matters
	TRNE F,F.PRB		;This a probe?
	 JRST OPNFN0		;Yup, don't bother setting the access pointer back
	.CALL [ SETZ            ;RESET POINTER TO BEGINNING OF FILE
		SIXBIT /ACCESS/
		%CLIN,,DATCHN(IDX)
		%CLIMM+%CLEND,,0]
	 JRST OPNACF		;ACCESS can fail on things like job devices
	JRST OPNFN0

OPNACF:	.CALL [ SETZ
		SIXBIT /CLOSE/
		%CLIN+%CLEND,,DATCHN(IDX)]
	 JFCL			;It can't fail...
	MOVEI T,.UAI		;ACCESS failed, so do it the slow way (reopen file)
	TLNE D,ST.BIN           ;UNLESS REALLY BINARY
	 MOVEI T,.UII
	.CALL [ SETZ
		SIXBIT /OPEN/
		%CLERR,,ERRCOD
		%CLBTW,,T       ;Appropriate mode
		%CLIN,,DATCHN(IDX)
		%CLIN,,DATDEV(IDX)
		%CLIN,,DATFN1(IDX)
		%CLIN,,DATFN2(IDX)
		%CLIN+%CLEND,,DATSNM(IDX)]
	 JRST OPNERR
	JRST OPNFN0

OPNOUT: MOVEI T,.UAO            ;ASSUME TEXT MODE
	TLNE D,ST.BIN           ;UNLESS REALLY BINARY
	 MOVEI T,.UIO
	.CALL [ SETZ
		SIXBIT /OPEN/
		%CLERR,,ERRCOD  ;Error code
		%CLBTW,,T       ;Appropriate mode
		%CLIN,,DATCHN(IDX)
		%CLIN,,DATDEV(IDX)
		%CLIN,,[SIXBIT \_LSPM_\]
		%CLIN,,[SIXBIT \OUTPUT\]
		%CLIN+%CLEND,,DATSNM(IDX)]
	 JRST OPNERR
	SETZM DATLEN(IDX)	;Due to ITS lossage must keep our own length for output files
]	;END IFN ITS

IFN TNX,[
	SETZM DATRFJ(IDX)	;Nothing to rename to now
	TRNE IDX,1
	 TLO D,ST.OUT		;COMGJF wants output file
	PUSHJ P,COMGJF		;Get JFN in AC1
	 JRST JSYSER		;Error: return it to the user
	HRRZM 1,DATJFN(IDX)	;JFN for this index
	TRNN IDX,1
	JRST	[TLNN D,ST.BIN
		  SKIPA 2,[070000,,OF%RD+OF%PLN]	;Input, ASCII, no line numbers!
		   MOVE 2,[440000,,OF%RD]		;Input, 36-bit
		 JRST .+4]
	TLNN D,ST.BIN
	 SKIPA 2,[070000,,OF%WR]	;Output, ASCII
	  MOVE 2,[440000,,OF%WR]	;Output, 36-bit
	TLNE D,ST.PDT
	 TRO 2,OF%PDT
	OPENF			;Open the file
	 JRST JSYSER		;Here if some error
	SETZM DATLEN(IDX)	;Will keep track of file lengths ourself
	TRNN IDX,1		;Output file, don't do QFASL-P check
	 TLNN D,ST.BIN		;Don't try to QFASLP for text files
	  JRST OPNFN0
	MOVE 1,DATJFN(IDX)
	BIN			;Read byte for QFASL-P
	ERJMP OPNFN0		;EOF, punt
	CAMN 2,[SIXBIT /QFASL/]
	 TROA F,F.QFP		;Checks out as a QFASL file
	 JRST [	TRNN F,F.DEF	;CHARACTERS DEFAULT?
		 JRST .+1	;NO
		TLZ D,ST.BIN	;YES, NOT BINARY THEN
		HLLM D,DATSTA(IDX)
		TRNE F,F.PRB
		 JRST .+1
		JRST OPNACF]	;And need to reopen in case it matters
	TRNE F,F.PRB		;If a probe, no need to set file pointer back
	 JRST OPNFN0
	SETZ 2,			;Set pointer back to beginning of file
	SFPTR
	 JRST OPNACF		;For files that can't be set back, just reopen
	JRST OPNFN0

OPNACF:	MOVE 1,DATJFN(IDX)
	HRLI 1,(CO%NRJ)		;Don't release the JFN
	CLOSF
	 ERJMP JSYSER
	HRRZS 1
	TLNN D,ST.BIN
	 SKIPA 2,[070000,,OF%RD+OF%PLN]	;Input, ASCII, no line numbers!
	  MOVE 2,[447400,,OF%RD]	;Input, dump mode
	OPENF			;Re-open file
	 JRST JSYSER		;Shouldn't happen, but...
]	;END IFN TOP20

OPNFN0:	MOVEI A,[ASCIZ \OPEN \]
	PUSHJ P,COMCTL
	SKIPE PTCVER
	 JRST OPNFN3
	PUSHJ P,COMVRS
	MOVEI BYTE,40
	PUSHJ P,COMCHO
OPNFN3:
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /RFDATE/
		%CLIN,,DATCHN(IDX)
		%CLOUT+%CLEND,,A]
	 SETZ A,                ;ASSUME 0 IF CALL FAILS
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	MOVEI 2,A		;Return values starting in A
	MOVEI 3,1		;Want one values (last write date)
	RFTAD
	 ERJMP JSYSER
]	;END IFN TNX
	PUSHJ P,COMDTO          ;OUTPUT DATE/TIME FROM A
	MOVEI BYTE,40
	PUSHJ P,COMCHO
IFN ITS,[
	TRNN IDX,1              ;RETURN 0 LENGTH FOR OUTPUT FILES
	 .CALL [ SETZ
		 SIXBIT /FILLEN/
		 %CLIN,,DATCHN(IDX)
		 %CLOUT+%CLEND,,A] ;SIZE IN 36 BIT BYTES
	  SETZ A,               ;HMM...
]	;END IFN ITS
IFN TNX,[
	SETZ A,
	TRNE IDX,1
	 JRST OPNFN1		;Output file, return 0 length
	MOVE 1,DATJFN(IDX)
	MOVE 2,[2,,.FBBYV]	;Read two words: byte size info, and number of bytes
	MOVEI 3,T		;Return info in T and TT
	GTFDB
	 ERJMP JSYSER
	MOVE A,TT
	LDB TT,[300600,,T]	;Get byte size
	HRLZI T,ST.BIN
	TDNN T,DATSTA(IDX)	;If binary mode, do calculation
	 JRST [CAIN TT,7	;ASCII mode, was original byte size 7 bits?
		JRST OPNFN1	;Yes, then A contains exact number of bytes
	       IMULI A,5	;Else fudge multiplying by number of bytes per word
	       JRST .+1]	;And do harder calculation
	MOVEI T,36.
	IDIVI T,(TT)		;And calculate number of bytes per word
	ADDI A,-1(T)		;Roundoff correctly
	IDIVI A,(T)		;A gets number of words in the file
]	;END IFN TNX
	HRLZI T,ST.BIN          ;BINARY MODE MULTIPLIES BY APPROPRIATE AMOUNT
	TDNN T,DATSTA(IDX)
	 JRST OPNFN1            ;A HAS ACTUAL LENGTH
	IMUL A,DATBPW(IDX)
OPNFN1:	MOVEM A,DATLEN(IDX)
	PUSHJ P,COMDCO          ;OUTPUT IN DECIMAL
	MOVEI A,[ASCIZ \ NIL\]	;ASSUME NOT QFASL
	TRZE F,F.QFP
	 MOVEI A,[ASCIZ \ T\]
	PUSHJ P,COMSTO          ;STRING-OUT THE APPROPRIATE RESPONSE
	TRZN F,F.DEF
	 JRST OPNFN2
	MOVEI A,[ASCIZ \ NIL\]	;ASSUME NOT CHARACTERS
	HRLZI T,ST.BIN
	TDNN T,DATSTA(IDX)
	 MOVEI A,[ASCIZ \ T\]
	PUSHJ P,COMSTO
OPNFN2:	MOVEI BYTE,215          ;A NEWLINE
	PUSHJ P,COMCHO
	PUSHJ P,COMRFO          ;OUTPUT THE REAL FILENAMES
	MOVEI BYTE,215
	PUSHJ P,COMCHO
	TRZN F,F.PRB
	 JRST OPNFPS            ;IF NOT A PROBE, THEN WE ARE DONE
	PUSHJ P,COMSND
IFN ITS,[
	.CALL [ SETZ            ;ELSE A PROBE, SO CLOSE THE CHANNEL, AS WE ARE DONE WITH IT
		SIXBIT /CLOSE/
		%CLIN+%CLEND,,DATCHN(IDX)]
	 JFCL                   ;HMM...OH WELL
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)	;A probe, so close channel
	CLOSF
	 JFCL
]	;END IFN TNX
	SETZM DATSTA(IDX)       ;MAKE SURE WORLD KNOWS CHANNEL IS CLOSED
	JRST CTLLOP

OPNFPS:	PUSHJ P,BUFALO          ;ALLOCATE A BUFFER
	PUSHJ P,COMSND
	MOVEI T,ST%OPN          ;STATE IS NOW OPEN
	HRRM T,DATSTA(IDX)
	HRLZI T,ST.ACT		;CHANNEL IS NOW ACTIVE
	IORM T,DATSTA(IDX)
IFN ITS,[
	MOVE T,CHABIT(IDX)
	.SUSET [.SIMSK2,,T]     ;ENABLE INTERRUPTS ON THE CHAOS CHANNEL
	ANDCAM T,SSYDF2	        ;Update saved copy of DS2
	.SUSET [.SADF2,,T]
	.SUSET [.SIIFPIR,,T]	;Start the ball rolling with an interrupt
]	;END IFN ITS
IFN TNX,[
	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	AIC			;Enable interrupts on this channel
	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	IIC			;Force interrupt on channel to start ball rolling
]	;END IFN TNX
	JRST CTLLOP             ;WAIT FOR MORE WORK

IFN ITS,[
;Send version number over
COMVRS:	MOVE TT,DATFN2(IDX)      ;RETURN FN2 AS VERSION
	;SEND THE VERSION NUMBER IN DECIMAL OR -1 IF NOT A NUMBER
	;IF PARTIAL NUMBER SEND THAT
	MOVEI A,0		;SET IF ANY DIGITS OUTPUT
COMVR0:	MOVEI T,0
	LSHC T,6
	MOVEI BYTE,40(T)
	CAIL BYTE,"0
	 CAILE BYTE,"9
	  JRST COMVR1
	PUSHJ P,COMCHO
	MOVEI A,1
	JUMPN TT,COMVR0
COMVR1:	JUMPN A,CPOPJ
	MOVEI BYTE,"-
	PUSHJ P,COMCHO
	MOVEI BYTE,"1
	PUSHJ P,COMCHO
	POPJ P,

;Output filespec to the control stream from DATxxx
COMRFO:	MOVE A,DATDEV(IDX)      ;DEVICE NAME
	CAMN A,[SIXBIT /DSK/]   ;If DSK, then send machine name
	 MOVE A,MACNAM
	PUSHJ P,COMSXO
	MOVEI A,[ASCIZ \: \]	;COLON TERMINATES DEVICE
	PUSHJ P,COMSTO
COMRF2:	SKIPN A,DATSNM(IDX)      ;THEN SNAME
	 JRST .+4
	  PUSHJ P,COMSXO
	  MOVEI A,[ASCIZ \; \]	;SEMICOLON TERMINATES SNAME
	  PUSHJ P,COMSTO
	SKIPN A,DATFN1(IDX)	;FIRST FILENAME
	 JRST [	SKIPN A,DATFN2(IDX)
		 POPJ P,
		MOVEI BYTE,"
		PUSHJ P,COMCHO
		JRST COMSXO ]
	PUSHJ P,COMSXO
	SKIPN A,DATFN2(IDX)	;FINALLY, SECOND FILENAME
	 POPJ P,
	MOVEI BYTE,40		;SPACE ENDS FN1
	PUSHJ P,COMCHO
	JRST COMSXO             ;TAIL RECURSIVE CALL TO SIXBIT OUTPUT

;Version of COMRFO which omits the default device entirely rather than plugging in the host
COMRF1:	MOVE A,DATDEV(IDX)      ;DEVICE NAME
	CAMN A,[SIXBIT /DSK/]   ;If DSK, then send nothing
	 JRST COMRF2
	JRST COMRFO
]	;END IFN ITS

IFN TNX,[
COMRFO:	SKIPA 3,[111110,,JS%PAF]	;Device, directory, filename, file type, version
COMVRS:	 MOVE 3,[000010,,0]	;Only return generation
	HRROI 1,RESBLK		;Output to canonical place
	MOVE 2,DATJFN(IDX)
	JFNS
	 ERJMP JSYSER
	JRST COMRES		;Output result block to control packet
]	;END IFN TNX

;Handle failing .CALL OPEN's
IFN TNX, JSYSER:
COMFER:
OPNERR:	PUSHJ P,OPNERP		;Setup error packet
	PUSHJ P,COMSND          ;Send the packet
	JRST CTLLOP             ;Then wait for more work

OPNERP:	MOVEI A,[ASCIZ \ERROR \]
	PUSHJ P,COMCTL          ;Start off error packet, open failed error code
IFN ITS,[
	MOVE T,ERRCOD		;Get the error code returned
	MOVEI A,ERR3CD(T)	;Get the appropriate 3 letter code
	PUSHJ P,COMSTO
	MOVEI A,[ASCIZ \F \]
	PUSHJ P,COMSTO
	.SUSET [.SPICLR,,[0]]	;ERR device can be used at interrupt level
	.CALL [ SETZ            ;Now open ERR device to get error message
		SIXBIT /OPEN/
		%CLBIT,,.UAI
		%CLIMM,,ERRCH
		%CLIN,,[SIXBIT /ERR/]
		%CLIMM,,4       ;Use FN2 as error code word
		%CLIN+%CLEND,,ERRCOD]
	 .LOSE %LSSYS
	MOVEI T,ERRLEN-1        ;Read a reasonable number of character
	MOVE TT,[440700,,ERRBUF]
	.CALL [ SETZ
		SIXBIT /SIOT/
		%CLIMM,,ERRCH
		%CLIN,,TT
		%CLIN+%CLEND,,T]
	 .LOSE %LSSYS
	.CALL [ SETZ
		SIXBIT /CLOSE/
		%CLIMM+%CLEND,,ERRCH]
	 .LOSE %LSSYS
	SETZ BYTE,
	IDPB BYTE,TT            ;Insure trailing null
	MOVE A,[440700,,ERRBUF]	;Only include up to first control char
	ILDB T,A
	CAIL T,40		;Less than space is first char not of interest
	 JRST .-2
	DPB BYTE,A
	MOVEI A,ERRBUF          ;Output error string to packet
	PUSHJ P,COMSTO
	.SUSET [.SPICLR,,[-1]]	;Done with use of any shared resources
]	;END IN ITS

IFN TNX,[
	MOVEI 1,.FHSLF
	PUSHJ P,$GETER		;Get last error that happened
	 PUSHJ P,CTLERR
	HRRZ D,2		;The number of the error
	HRROI 1,RESBLK		;Output to canonical place, error in AC2
	MOVEI 3,RESLEN-1	;Maximum number of bytes we can handle
	ERSTR
	 JFCL			;Undefined error number??
	  JFCL			;Won't fit -- too bad
IFN 10X,[
	SETZ 3,
	IDPB 3,1		;Put in null
];IFN 10X
	CAIN D,GJFX19		;These three, and only these, may return FNF
	 JRST .+3
	CAIE D,GJFX24
	 CAIN D,OPNX2
	  JRST	[MOVE B,[ASCII \FNF\]
		 JRST JSYER3]
	MOVE T,[440700,,RESBLK]
	MOVE TT,[440700,,B]
	MOVE B,[ASCII \???\]
	MOVEI C,3
	TRO F,F.SPAC		;Space seen last time
	;; Scan through returned string, and build a three letter abbreviation for
	;; the error
JSYER1:	ILDB BYTE,T		;Next error character
	JUMPE BYTE,JSYER2	;Null, end of string reached
IFN 10X,[
	CAIN BYTE,":		;A colon
	 CAIE C,2		;Before the first space
	 JRST JSYE1A
	ADD TT,[070000,,0]	;Means back up the output pointer
	AOJA C,JSYER1
JSYE1A:
];IFN 10X
	CAIN BYTE,40		;A space
	 TROA F,F.SPAC		;Yes, so flag it
	  TRZN F,F.SPAC		;Seen a space last time?
	   JRST JSYER1		;Nope, so don't store byte
	CAIL BYTE,"a		;Uppercase lowercase characters
	 CAILE BYTE,"z
	  SKIPA
	   SUBI BYTE,"a-"A
	IDPB BYTE,TT		;Else store byte in error code
	SOJG C,JSYER1		;Do three bytes
JSYER2:	CAMN B,[ASCII \FNF\]
	 ADDI B,100000		;Don't allow spurious FNF to creep in!
JSYER3:	MOVEM B,ERRCOD
	MOVEI A,ERRCOD
	PUSHJ P,COMSTO		;Output three letter code
	MOVEI A,[ASCIZ \ F \]
	PUSHJ P,COMSTO
	PUSHJ P,COMRES
]	;END IFN TNX
	POPJ P,

IFN ITS,[
;;; Table of 3 letter codes
ERR3CD:	IRPS CODE,,[IS0,NSD,WDI,TMT,FNF,DRF,DVF,DNR,DNA,IFN,MNA,FAE,BCN,TMA,PNM,DIN,NED,LDO,SCO,LCK,MFF,DNP,WLK,TML,TFA,CMJ,CGA,BAD,WTD,NSJ,VCS,NCA,NTL,OPG,JGA,ISC,CNO,IBE,URF,LNF]
	ASCIZ \CODE \
	TERMIN
]	;END IFN ITS

;;; Close a data channel
COMCLO:	TRNN F,F.FHN            ;HAVE A FILE HANDLE?
	 JRST COMBAD            ;NOPE, ERROR
	JUMPGE BC,COMBAD        ;NO OPTIONS TO THE CLOSE COMMAND
	SKIPL T,DATSTA(IDX)	;CHANNEL ACTIVE?
	 CERR CNO,[CHANNEL NOT OPEN]
	TLNE T,ST.DIR		;Was it a directory listing?
	 JRST COMCLD
	MOVEI A,[ASCIZ \CLOSE \];SUCCESSFUL RESPONSE
	PUSHJ P,COMCTL          ;SETUP CONTROL PACKET
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /RFDATE/
		%CLIN,,DATCHN(IDX)
		%CLOUT+%CLEND,,CLODAT]
	 SETZM CLODAT           ;ASSUME 0 IF CALL FAILS
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	MOVEI 2,A		;Return values starting in A
	MOVEI 3,1		;Want one value (last write date)
	RFTAD
	 ERJMP JSYSER
	MOVEM A,CLODAT
]	;END IFN TNX
	TRNE IDX,1		;Input file?
	 JRST CLOLE0		;Nope, output, use calculated length
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /FILLEN/
		%CLIN,,DATCHN(IDX)
		%CLOUT+%CLEND,,A] ;SIZE IN 36 BIT BYTES
	 SETZ A,                ;HMM...
]	;END IFN ITS
IFN TNX,[
	SETZ A,
	MOVE 1,DATJFN(IDX)
	MOVE 2,[2,,.FBBYV]	;Read two words: byte size info, and number of bytes
	MOVEI 3,T		;Return info in T and TT
	GTFDB
	 ERJMP JSYSER
	MOVE A,TT
	LDB TT,[300600,,T]	;Get byte size
	HRLZI T,ST.BIN
	TDNN T,DATSTA(IDX)	;If binary mode, do calculation
	 JRST [CAIN TT,7	;ASCII mode, was original byte size 7 bits?
		JRST CLOLE1	;Yes, then A contains exact number of bytes
	       JRST .+1]	;And do harder calculation
	MOVEI T,36.
	IDIVI T,(TT)		;And calculate number of bytes per word
	ADDI A,-1(T)
	IDIVI A,(T)		;A gets number of words in the file
]	;END IFN TNX
	HRLZI T,ST.BIN          ;BINARY MODE MULTIPLIES BY 2, TEXT MODE BY 5
	TDNN T,DATSTA(IDX)
	 SKIPA T,[5]            ;TEXT: 5
	  MOVEI T,2             ;BINARY: 2
	IMULI A,(T)
	JRST CLOLE1

CLOLE0:	MOVE A,DATLEN(IDX)	;Actual number of bytes in file
	HRLZI T,ST.BIN
	TDNN T,DATSTA(IDX)	;If not binary mode then this is the number we want
	 JRST CLOLE1
	MOVE T,DATBPW(IDX)
	ADDI A,-1(T)		;In order to round up
	IDIVI A,(T)		;Calculate number of words in file
	IMULI A,(T)		;Then calculate number of bytes rounded up
;	JRST CLOLE1

CLOLE1:	MOVEM A,CLOLEN
IFN ITS, PUSHJ P,CLOSIT		;Close the channel
IFN TNX, PUSHJ P,CLONRJ	;Close, but don't release JFN
	SKIPE PTCVER
	 JRST CLOLE2
	PUSHJ P,COMVRS
	MOVEI BYTE,40
	PUSHJ P,COMCHO
CLOLE2:	MOVE A,CLODAT
	PUSHJ P,COMDTO          ;OUTPUT DATE/TIME FROM A
	MOVEI BYTE,40
	PUSHJ P,COMCHO
	MOVE A,CLOLEN           ;FILE LENGTH
	PUSHJ P,COMDCO          ;OUTPUT IN DECIMAL
	;; Don't send QFASL info
	MOVEI BYTE,215          ;A NEWLINE
	PUSHJ P,COMCHO
	PUSHJ P,COMRFO          ;OUTPUT THE REAL FILENAMES
	MOVEI BYTE,215
	PUSHJ P,COMCHO
CLOLED:	MOVEI A,CPOPJ           ;Routine to call in case mark already received
	PUSHJ P,COMSSY          ;Send/receive synchronous mark
	PUSHJ P,COMSND          ;Send control response
	HRLZI T,ST.SYN          ;Wait for mark to go out, or mark to come in
IFN ITS,[
	TDNE T,DATSTA(IDX)
	 .HANG
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	RLJFN
	 JFCL
	;; Nothing winning like .HANG, so use small sleeps
	TDNE T,DATSTA(IDX)
	 JRST	[MOVEI 1,1
		 DISMS
		 JRST .-1]
]	;END IFN TNX
	SETZM DATSTA(IDX)	;Done with channel now, deactivate it
	JRST CTLLOP

IFN TNX, CLONRJ: TROA F,F.NRJ
CLOSIT:
IFN TNX, TRZ F,F.NRJ
	MOVE T,DATSTA(IDX)
	TLNE T,ST.DIR		;Directory command?
	 JRST CLODIR		;Yes, finish up specially
	TRNN IDX,1		;Output file?
	 JRST CLOSE0		;Nope, proceed
	HRRZ T,DATSTA(IDX)
	CAIN T,ST%OPN           ;Write out in-core buffer if channel state is OPEN
	 PUSHJ P,WRIFOR
IFN ITS,[
	SKIPN DATFN1(IDX)       ;Has file been DELEWO'ed?
	 JRST CLOSE1	    	;Yes, don't RENMWO or set author
	.CALL [ SETZ
		SIXBIT /RENMWO/
		%CLIN,,DATCHN(IDX)
		%CLIN,,DATFN1(IDX)
		%CLIN+%CLEND,,DATFN2(IDX)]
	 CERR CRF,[CANNOT RENAME OUTPUT FILE TO REAL NAMES]
	.CALL [ SETZ
		SIXBIT /SAUTH/
		%CLIN,,DATCHN(IDX)
		%CLIN+%CLEND,,HSNAME]
	 JFCL			;Unusual, but not fatal
CLOSE1:	.CALL [ SETZ            ;GET TRUENAME TO RETURN TO USER
		SIXBIT /RFNAME/
		%CLIN,,DATCHN(IDX)
		%CLOUT,,DATDEV(IDX)
		%CLOUT,,DATFN1(IDX)
		%CLOUT,,DATFN2(IDX)
		%CLOUT+%CLEND,,DATSNM(IDX)]
	 JFCL                   ;WELL, IT SHOULDN'T BUT...
]	;END IFN ITS
IFN TNX,[
CLOSE0:	MOVE 1,DATJFN(IDX)
	HRLI 1,(CO%NRJ)		;Close file, but keep around JFN
	CLOSF
	 ERJMP JSYSER		;Ain't much else we can do...
	SKIPN T,DATRFJ(IDX)	;Special action -- rename or delete
	 JRST CLOSE2		;Nope, proceed
	JUMPL T,CLOSE3		;Delete
	MOVE 1,DATJFN(IDX)
	MOVE 2,T
	RNAMF
	 ERJMP JSYSER		;Oh well, not much to do on errors here
	MOVE 1,DATRFJ(IDX)
	MOVEM 1,DATJFN(IDX)
	JRST CLOSE2
CLOSE3:	MOVE 1,DATJFN(IDX)	;Delete the file
	HRLI 1,(DF%NRJ)
	DELF
	 JFCL
CLOSE2:	MOVE 1,DATJFN(IDX)
	TRNN F,F.NRJ
	 RLJFN
	  JFCL			;Ain't much we can do on errors
]	;END IFN TNX
IFN ITS, CLOSE0:
CLODON:	MOVE T,DATSTA(IDX)	;Get channel status
	MOVEI TT,(T)
	CAIN TT,ST%OPN		;Was the channel open?
	 HRRI T,ST%CLO		;Yes, then close it
	MOVEM T,DATSTA(IDX)
	PUSHJ P,BUFDAL	  	;DEALLOCATE THE CORE BUFFER
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /CLOSE/
		%CLIN+%CLEND,,DATCHN(IDX)]
	 JFCL                   ;HMMMM...."I GUESS WE'LL SURVIVE"
]	;END IFN ITS
	POPJ P,

;;; FILEPOS: for input files only
COMFIL:	TRNN F,F.NWL            ;Can't have a newline
	 TRNN F,F.FHN           ;And must have a file handle
	  JRST COMBAD
	SKIPGE DATSTA(IDX)      ;IDX must be active
	 TRNE IDX,1             ;And must be a read IDX
	  CERR IFH,[ILLEGAL FILE HANDLE FOR FILEPOS]
	JUMPL BC,COMBAD         ;Also need an argument
	PUSHJ P,COMDCI	  	;Read the arg in decimal
	JUMPGE BC,COMBAD        ;Better be the end
	HRLZI T,ST.BIN          ;Is this a binary channel?
	TDNN T,DATSTA(IDX)
	 JRST FILNBN            ;Nope, filepos is in A
	IDIV A,DATBPW(IDX)	;A is number of words in, B is number of bytes after that
	HRLI A,(B)              ;Need to save this for interrupt routine
FILNBN:	MOVEM A,DATSYN(IDX)     ;Location reserved for synchronous routines
	MOVEI A,FILSYN          ;Routine to call
	PUSHJ P,COMSSY	  	;Setup for the sync mark
	MOVEI A,[ASCIZ \FILEPOS\]
	PUSHJ P,COMCTL
	PUSHJ P,COMSND
	HRLZI T,ST.SYN          ;Wait for mark to go out
IFN ITS,[
	TDNE T,DATSTA(IDX)
	 .HANG
]	;END IFN ITS
IFN TNX,[
	;; Nothing winning like .HANG, so use small sleeps
	TDNE T,DATSTA(IDX)
	 JRST	[MOVEI 1,1
		 DISMS
		 JRST .-1]
]	;END IFN TNX
	JRST CTLLOP             ;Ok, all done, go back for more

;;; Here after sync mark gets sent.  Called from interrupt and main program level
FILSYN:	HRRZ T,DATSYN(IDX)      ;Get word (byte in text mode) address to ACCESS to
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /ACCESS/
		%CLIN,,DATCHN(IDX)
		%CLIN+%CLEND,,T]
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	MOVE 2,T		;Where pointer is to get set to
	SFPTR
]	;END IFN TNX
	 AERR CPOPJ,CSP,[CANNOT SET POINTER]
	SETZM DATBPT(IDX)       ;No state is left
	SETZM DATBCT(IDX)
	SETZM DATLWD(IDX)
	HRRI A,ST%OPN		;Channel is now in open state
	TRNE IDX,1	        ;Output channel?
	 POPJ P,		;Yes, then we are done
	HLRZ T,DATSYN(IDX)      ;Get number of bytes into first word
	JUMPE T,CPOPJ	   	;If none, then just return.
	PUSHJ P,REABUF	  	;Else read in the next bufferful
	SKIPG T,DATBCT(IDX)     ;Any bytes to hack?
	 POPJ P,		;Nope, just return, EOF will be sent next interrupt
	HLRZ TT,DATSYN(IDX)
	SUBI T,(TT)	        ;Calculate number of bytes that will remain in buffer
	JUMPLE T,FILSY0	 	;If it's gonna be 0 or negative, then EOF
	MOVEM T,DATBCT(IDX)     ;Else this is the new count
	IBP DATBPT(IDX)	 	;Step the pointer to the appropriate spot
	SOJG TT,.-1
	POPJ P,

FILSY0:	SETZM DATBPT(IDX)
	SETZM DATBCT(IDX)
	SETZM DATLWD(IDX)
	POPJ P,

;;; SET-BYTE-SIZE <new-byte-size> <new-filepos-in-terms-of-old-byte-size-for-input-files>
COMSBS:	JUMPL BC,COMBAD		;End of packet, losing format
	TRZE F,F.NWL		;Can't have new line either
	 JRST COMBAD
	SKIPGE T,DATSTA(IDX)	;This channel active?
	 TLNN T,ST.BIN		;And a binary channel?
	  CERR ISC,[ILLEGAL CHANNEL FOR SET-BYTE-SIZE]
	PUSHJ P,COMDCI		;Read new byte size in decimal
	JUMPL BC,COMBAD
	TRZE F,F.NWL
	 JRST COMBAD
	HRLM A,DATBYT(IDX)	;Remember new byte size
	TRNE IDX,1		;Need to set a filepos?
	 JRST SBSNFP		;Nope, ignore rest of packet
	PUSHJ P,COMDCI		;Else read the filepos
	IDIV A,DATBPW(IDX)	;A is number of words in, B is number of bytes after that
				; of current position in file
	HRLI A,(B)              ;Need to save this for interrupt routine
	MOVEM A,DATSYN(IDX)
SBSNFP:	MOVEI A,SBSSYN          ;Routine to call
	PUSHJ P,COMSSY	  	;Setup for the sync mark
	MOVEI A,[ASCIZ \SET-BYTE-SIZE\]
	PUSHJ P,COMCTL
	PUSHJ P,COMSND
	HRLZI T,ST.SYN          ;Wait for mark to go out
IFN ITS,[
	TDNE T,DATSTA(IDX)
	 .HANG
]	;END IFN ITS
IFN TNX,[
	;; Nothing winning like .HANG, so use small sleeps
	TDNE T,DATSTA(IDX)
	 JRST	[MOVEI 1,1
		 DISMS
		 JRST .-1]
]	;END IFN TNX
	JRST CTLLOP             ;Ok, all done, go back for more

;;; Here upon receipt of synchronous mark
SBSSYN:	HLRZS TT,DATBYT(IDX)	;Set up new byte size as current byte size
	TRNN IDX,1		;If reading from file do filepos and return
	 JRST FILSYN
	SKIPE DATBPT(IDX)	;If a byte pointer is around, change its byte size
	 DPB TT,[360600,,DATBPT(IDX)]
	HRRI A,ST%OPN		;Channel is now in open state
	MOVEI T,36.		;Calculate and remember number of bytes per word
	IDIVI T,(TT)
	MOVEM T,DATBPW(IDX)
	POPJ P,			;Then we are done

;;; DELETE, RENAME and other sundry file operations

;;; DELETE
COMDEL:	TRNN F,F.FHN		;Did we have a file handle?
	 JRST DELFIL		;Nope, filename must be specified
	JUMPGE BC,COMBAD	;Must be end of command string here
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /DELEWO/
		%CLIN+%CLEND,,DATCHN(IDX)]
	 JFCL			;Can't fail, can it??
	SETZM DATFN1(IDX)	;Flag file as deleted
]	;END IFN ITS
IFN TNX,[
	SKIPGE 1,DATRFJ(IDX)	;Skip if don't have a JFN to release first
	 RLJFN
	  JFCL
	SETOM DATRFJ(IDX)	;Flag for deletion later
]	;END IFN TNX
	MOVEI A,[ASCIZ \DELETE\]
	PUSHJ P,COMCTL
	PUSHJ P,COMSND
	JRST CTLLOP

DELFIL:	TRZN F,F.NWL		;Newline?
	 JRST COMBAD		;Nope, bad command format
	MOVEI IDX,MAXIDX	;Use the temporary channel for this
IFN ITS,[
	PUSHJ P,COMPFN		;Parse the filename to be deleted
	TRZN F,F.NWL		;Check for correct format
	 JRST COMBAD
	.CALL [ SETZ
		SIXBIT /DELETE/
		%CLERR,,ERRCOD  ;Error code
		%CLIN,,DATDEV(IDX)
		%CLIN,,DATFN1(IDX)
		%CLIN,,DATFN2(IDX)
		%CLIN+%CLEND,,DATSNM(IDX)]
	 JRST COMFER		;File error, tell about it
]	;END IFN ITS
IFN TNX,[
	SETZ D,			;COMGJF wants input file
	PUSHJ P,COMGJF		;Get JFN
	 JRST JSYSER		;Error, return it to the user
	DELF
	 JRST JSYSER
]	;END IFN TNX
	MOVEI A,[ASCIZ \DELETE\]
	PUSHJ P,COMCTL
	PUSHJ P,COMSND
	JRST CTLLOP


;;; RENAME
COMREN:	TRZN F,F.NWL		;Both formats require newline
	 JRST COMBAD
	TRNN F,F.FHN		;Use an open file?
	 JRST RENFIL		;Nope, need two filenames
IFN ITS,[
	PUSH P,DATDEV(IDX)
	PUSH P,DATSNM(IDX)
	PUSHJ P,COMPFN		;Parse the filename
	TRZN F,F.NWL		;Must be terminated by newline
	 JRST COMBAD
	POP P,A			;Old directory
	POP P,B			;Old device
	CAMN A,DATSNM(IDX)
	 CAME B,DATDEV(IDX)
	 JRST RENRDD
	TRNE IDX,1		;An output file?
	 JRST RENCOM		;Yes, using a temp name anyway, just proceed
	.CALL [ SETZ
		SIXBIT /RENMWO/
		%CLERR,,ERRCOD  ;Error code
		%CLIN,,DATCHN(IDX)
		%CLIN,,DATFN1(IDX)
		%CLIN+%CLEND,,DATFN2(IDX)]
	 JRST COMFER
]	;END IFN ITS
IFN TNX,[
	SKIPLE 1,DATRFJ(IDX)	;If previous rename JFN, release it first
	 RLJFN
	  JFCL
	HRLZI D,ST.OUT		;COMGJF wants output file
	PUSHJ P,COMGJF		;Get a JFN for the file
	 JRST JSYSER
	MOVEM 1,DATRFJ(IDX)	;Defer processing until file gets closed
]	;END IFN TNX

RENCOM:	MOVEI A,[ASCIZ \RENAME\]
	PUSHJ P,COMCTL
	PUSHJ P,COMSND
	JRST CTLLOP

RENFIL:	MOVEI IDX,MAXIDX	;A phony IDX to use
IFN ITS,[
	PUSHJ P,COMPFN		;Parse the from filename
	TRZN F,F.NWL		;Must have trailing newline
	 JRST COMBAD
IRPS WHAT,,[DATDEV,DATFN1,DATFN2,DATSNM]
	PUSH P,WHAT(IDX)
TERMIN
	PUSHJ P,COMPFN		;Parse the next filespec
	TRZN F,F.NWL
	 JRST COMBAD
	MOVE A,0(P)
	MOVE B,-3(P)
	CAMN A,DATSNM(IDX)
	 CAME B,DATDEV(IDX)
	 JRST RENRDD
	.CALL [ SETZ
		SIXBIT /RENAME/
		%CLERR,,ERRCOD
		%CLIN,,B
		%CLIN,,-2(P)
		%CLIN,,-1(P)
		%CLIN,,A
		%CLIN,,DATFN1(IDX)
		%CLIN+%CLEND,,DATFN2(IDX)]
	 JRST COMFER		;Report file error
	SUB P,[4,,4]		;Not really necessary, but get rid of pushed cruft
	JRST RENCOM

RENRDD:	CERR RDD,[CANNOT RENAME ACROSS DIRECTORIES]
]	;END IFN ITS

IFN TNX,[
	SETZ D,			;Get input file first
	PUSHJ P,COMGJF		;Get JFN for file
	 JRST JSYSER		;Can't get JFN, so return
	MOVEM 1,DATRFJ(IDX)	;Save JFN for later PUSHJ
	TLO D,ST.OUT		;Next file is 'output' file
	PUSHJ P,COMGJF
	 JRST [MOVE 1,DATRFJ(IDX)
	       RLJFN		;Can't get output JFN, so release input JFN and give error
		JFCL
	       JRST JSYSER]
	MOVE 2,1
	MOVE C,1		;Remember in case of error
	MOVE 1,DATRFJ(IDX)
	RNAMF
	 JRST [MOVE 1,DATRFJ(IDX)
	       RLJFN
	        JFCL
	       MOVE 1,C
	       RLJFN
	        JFCL
	       JRST JSYSER]
	MOVE 1,C
	RLJFN
	 JFCL
	JRST RENCOM
]	;END IFN TNX

;;; CONTINUE command.  Continue processing after a recoverable asynchronous error
COMCON:	JUMPGE BC,COMBAD	;Better not have any more stuff
	TRNN F,F.FHN		;Need a file handle
	 JRST COMBAD
	SKIPL A,DATSTA(IDX)	;Channel must be active
CONCCC:	 CERR CCC,[CHANNEL CANNOT CONTINUE]
	MOVEI T,ST%ASY		;Must be in async mark state
	CAIN T,(A)
	 TLNE A,ST.UNC		;And must be continuable
	  JRST CONCCC
	HRRI A,ST%OPN		;Ok, so fix up
	MOVEM A,DATSTA(IDX)
	MOVEI A,[ASCIZ \CONTINUE\]
	PUSHJ P,COMCTL		;Send completion response
	PUSHJ P,COMSND
IFN ITS,[
	.CALL [ SETZ		;Continue the interrupted I/O operation
		SIXBIT /SIOT/
		%CLIN,,DATCHN(IDX)
		%CLIN,,DATBPT(IDX)
		%CLIN+%CLEND,,DATBCT(IDX)]
	 JRST CONERR		;Another IOC error, didn't really fix the problem
	.SUSET [.SPICLR,,[0]]	;Don't allow interrupts, and the continuation better not
				; do anything that causes them!
]	;END IFN ITS
IFN TNX,[
	PUSHJ P,DOSIO		;Continue I/O operation
	 JRST CONERR
	MOVEI 1,.FHSLF
	DIR
]	;END IFN TNX
	MOVE A,DATSTA(IDX)
	PUSHJ P,@DATICN(IDX)
	MOVEM A,DATSTA(IDX)
IFN ITS,[
	.SUSET [.SPICLR,,[-1]]
	MOVE T,CHABIT(IDX)
	ANDCAM T,SSYDF2		;Update saved copy of DF2 (can't hurt even if not masked)
	TRNE IDX,1		;Undefer interrupts if necessary
	 .SUSET [.SADF2,,T]
	.SUSET [.SIIFPIR,,T]	;Cause interrupt to start the ball rolling
]	;END IFN ITS
IFN TNX,[
	MOVEI 1,.FHSLF		;Turn interrupt system back on
	EIR
	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	AIC			;Reenable interrupts on this channel
	IIC			;Force interrupt on channel to start ball rolling
]	;END IFN TNX
	JRST CTLLOP		;Then done

CONERR:
IFN ITS,[
	.SUSET [.SPICLR,,[0]]	;Using shared resources, prevent timing screws
]	;END IFN ITS
IFN TNX,[
	MOVEI 1,.FHSLF
	DIR
]	;END IFN TNX
	PUSH P,DATICN(IDX)	;Save important stuff over the IOC error emission
	MOVE A,DATSTA(IDX)	;ICCERR wants status in A
	MOVEI D,DATICN-1(IDX)	;And continuation in c(1(D))
	PUSHJ P,[PUSHJ P,ICCERR] ;*K*L*U*D*G*E*
	POP P,DATICN(IDX)
IFN ITS,[
	.SUSET [.SPICLR,,[-1]]
]	;END IFN ITS
IFN TNX,[
	MOVEI 1,.FHSLF
	EIR
]	;END IFN TNX
	JRST CTLLOP		;Then done

IFN TNX,[
DOSIO:	MOVE 1,DATJFN(IDX)
	MOVE 2,DATBPT(IDX)
	MOVN 3,DATBCT(IDX)
	JUMPE 3,DOSIO1
	TRNE IDX,1
	 JRST DOSIOO		;Output
	SIN
	 ERJMP .+1
DOSIO1: PUSHJ P,ITSBP		;Turn BP in AC2 into an ITS standard byte pointer
	MOVEM 2,DATBPT(IDX)
	MOVNM 3,DATBCT(IDX)
	SKIPN 3			;Means we didn't make it all out
	 AOS (P)
	POPJ P,
DOSIOO:	SOUT
	 ERJMP DOSIO1
	JRST DOSIO1

ITSBP:	PUSH P,T
	LDB T,[360600,,2]	;PP field of BP in AC2
	JUMPN T,ITSBP0		;Some bits left, so is ok
	MOVEI T,44		;Make agree with ITS -- point off left of next word
	DPB T,[360600,,2]
	AOS 2
ITSBP0:	POP P,T
	POPJ P,
]	;END IFN TNX

;;; Directory command
DATNDR==:DATBYT			;Next directory, 0 = start, -1 = done
IFN ITS,[
DATDRP==:DATBPW			;File being processed (index to UFD)
.INSRT SYSTEM;FSDEFS
]	;END IFN ITS
IFN TNX,[
DATDRN==:DATBPW			;Directory number being processed
]

COMDIR:	SKIPN USERID
	 CERR NLI,[NOT LOGGED IN]
	TRNN F,F.FHN		;Must have file handle
	 CERR NFH,[MUST HAVE A FILE HANDLE]
	TRNE IDX,1		;Input index?
	 CERR CWD,[CHANNEL WRONG DIRECTION]
	SKIPGE DATSTA(IDX)
	 PUSHJ P,CLOSIT		;Close open channel
	SETZM DATSTA(IDX)
	MOVSI D,ST.DIR
DIROPT:	TRNE F,F.NWL		;End of options?
	 JRST DIRFNM
	PUSHJ P,COMRD5		;Get token
	 JUMPL BC,COMBAD
DIROLP:	MOVEI T,DIRLEN-1
DIROL1:	CAME A,DIRTAB(T)
	 SOJGE T,DIROL1
	JUMPL T,[CERR UDO,[UNKNOWN DIRECTORY OPTION]]
	XCT DIRACT(T)
	 JRST COMBAD
	JRST DIROPT

DIRTAB:	ASCII \DELET\		;Allow deleted files as well
	ASCII \FAST\
	ASCII \NO-EX\
	ASCII \DIREC\
DIRLEN==.-DIRTAB

DIRACT: TLOA D,ST.DEL
	TLOA D,ST.FST
	SKIPA
	TLOA D,ST.ALD

DIRFNM:	HLLM D,DATSTA(IDX)	;Save status bits
IFN ITS,[
	PUSHJ P,COMPFN		;Parse the filename spec
	PUSHJ P,LCKDIR		;Get DIRLCK
	PUSHJ P,GETMFD		;Read in the MFD
	 JRST [ SETZM DIRLCK ? JRST OPNERR ]
;The following might be nice, but the directory format of archives is evidently
;not 100% compatible since we get an MPV trying to look at the descriptors.
;So go ahead and get a file-not-found error if we try to take the directory of
;an archive.
;Note that it is necessary to read in the MFD even if the sname is not wildcarded,
;since the MFD is needed to decode file authors.
IFN 0,[	 JRST [	HLRZ A,DATDEV(IDX)	;Kludge around for archives
		TRZ A,77
		CAIE A,(SIXBIT/AR/)
		 JRST [ SETZM DIRLCK ? JRST OPNERR ]	;Device doesn't exist?
		PUSH P,DATDEV(IDX)
		MOVSI A,'DSK
		MOVEM A,DATDEV(IDX)
		PUSHJ P,GETMFD
		 JRST [	POP P,DATDEV(IDX) ? SETZM DIRLCK ? JRST OPNERR ]
		POP P,DATDEV(IDX)
		JRST .+1 ]
];IFN 0
	 
;; Allocate space for directory mapping
	MOVEI T,DIRBUF/2000
	PUSHJ P,PAGALO
	SETZM DATDRP(IDX)
]	;END IFN ITS

IFN TNX,[
	TLNE D,ST.ALD
	 JRST [	TLO D,ST.PON	;Do parse only
		SETZM DATDRN(IDX)
		JRST .+1]
	PUSHJ P,COMGJF		;Get JFN, with wildcards
	 JRST JSYSER
	MOVEM 1,DATJFN(IDX)	;Save it, with flags
]	;END IFN TNX

	SETZM DATNDR(IDX)	;Will start listing next time around
	MOVEI A,[ASCIZ \DIRECTORY\]
	PUSHJ P,COMCTL
	JRST OPNFPS		;Finish up like open

;;; Come here from REABUF when need some more input from a directory listing
;;; T has byte pointer to store into, TT has byte count
REDRBF:	PUSH P,A
	PUSH P,B		;Save some ac's
	PUSH P,BC
	PUSH P,BP

;; Directory loop, try to fill buffer with all info on one file, if we run out of room,
;; we back up the pointer to before the current file and return with that
	MOVE BP,T
	MOVE BC,TT
	SKIPN DATNDR(IDX)	;First time?
	 PUSHJ P,DIRHED		;Yes, print header
	PUSH P,BP		;Save byte pointer
	PUSH P,BC		;and counter
	MOVEM P,DIRPDL		;Save stack pointer

REDRB0:	PUSHJ P,DIRFIL		;Do one file
	 JRST REDBF1		;No file to do
	MOVEM BP,-1(P)		;Save updated byte pointer
	MOVEM BC,(P)		;and count
	JRST REDRB0

;; Done filling buffer, restore state and return
REDBF1:	MOVE P,DIRPDL
	POP P,TT		;Restore byte count
	POP P,T			;and pointer
	POP P,BP
	POP P,BC
	POP P,B
	POP P,A
	JRST REABF3		;Return to main body of code

;;; Come here from COMCLO for directory channel
COMCLD:	PUSHJ P,CLOSIT
	MOVEI A,[ASCIZ \CLOSE\]
	PUSHJ P,COMCTL
	JRST CLOLED

;;; Come here from CLOSIT when done with a directory channel
CLODIR:
IFN ITS,[
	MOVEI T,MFDBUF/2000
	PUSHJ P,PAGDAL
	MOVEI T,DIRBUF/2000
	PUSHJ P,PAGDAL
	SETZM DIRLCK
]	;END IFN ITS
	MOVE T,DATSTA(IDX)	;Get channel status
	MOVEI TT,(T)
	CAIN TT,ST%OPN		;Was the channel open?
	 HRRI T,ST%CLO		;Yes, then close it
	MOVEM T,DATSTA(IDX)
	JRST BUFDAL		;Deallocate the core buffer and return

IFN ITS,[
;; Lock the lock for the MFD and UFD pages and associated variables
LCKDIR:	SKIPE T,DIRLCK
	 CAIN IDX,(T)
	 SKIPA
	 CERR ODC,[TOO MANY DIRECTORY COMMANDS]
	HRROM IDX,DIRLCK	;Something random
	POPJ P,

;; Map in the MFD
GETMFD:	MOVEI T,MFDBUF/2000
	PUSHJ P,PAGALO
	.CALL [	SETZ
		SIXBIT /OPEN/
		%CLERR,,ERRCOD
		%CLBTW+%CLIMM,,.UII
		%CLIN,,DATCHN(IDX)
		%CLIN,,DATDEV(IDX)
		%CLIN,,[SIXBIT /M.F.D./]
		%CLIN,,[SIXBIT /(FILE)/]
		%CLIN+%CLEND,,DATSNM(IDX)]
	 POPJ P,
	MOVEI T,2000
	MOVE TT,[444400,,MFDBUF]
	.CALL [	SETZ
		SIXBIT /SIOT/
		%CLERR,,ERRCOD
		%CLIN,,DATCHN(IDX)
		%CLIN,,TT
		%CLIN+%CLEND,,T]
	 SETZM MFDBUF+MDCHK	;Normally 'M.F.D.
	.CALL [	SETZ
		SIXBIT /CLOSE/
		%CLIN+%CLEND,,DATCHN(IDX)]
	 JFCL
	MOVE T,MFDBUF+MDCHK
	CAMN T,[SIXBIT /M.F.D./]
	 AOS (P)
	POPJ P,
];ITS

;;; Printing routines
IFN ITS,[
;;; Print directory header info
DIRHED:	PUSHJ P,DIRCLF		;Empty pathname for special information
	MOVSI TT,ST.FST\ST.ALD
	TDNE TT,DATSTA(IDX)	;Fast option?
	 JRST DIRHDE		;Yes, skip rest of heading
	MOVEI A,[ASCIZ \SETTABLE-PROPERTIES DONT-REAP NOT-BACKED-UP AUTHOR CREATION-DATE REFERENCE-DATE\]
	PUSHJ P,DIRSCL
	MOVEI T,2000*36.
	MOVEI A,[ASCIZ \BLOCK-SIZE\]
	PUSHJ P,DIRDEC
	MOVEI A,[ASCIZ \PHYSICAL-VOLUME-FREE-BLOCKS\]
	PUSHJ P,DIRSTR
	MOVE T,[SQUOZE 0,NQS]
	.EVAL T,
	 .LOSE %LSSYS
	MOVSI C,-1
	TLC C,-1(T)		;AOBJN pointer
	MOVE T,[SQUOZE 0,QSFT]
	.EVAL T,
	 .LOSE %LSSYS
	PUSH P,T
	MOVE T,[SQUOZE 0,QPKID]
	.EVAL T,
	 .LOSE %LSSYS
	PUSH P,T
	MOVEI B,10.
DIRFR0:	MOVE TT,(P)		;QPKID
	ADDI TT,(C)		;(Q)
	MOVSS TT
	HRRI TT,T
	.GETLOC TT,
	JUMPL T,DIRFR1
	MOVEI BYTE,",
	TRNN C,-1
	 MOVEI BYTE,40
	PUSHJ P,DIRCHO
	PUSHJ P,DIRNUM
	MOVEI BYTE,":
	PUSHJ P,DIRCHO
	MOVE TT,-1(P)		;QSFT
	ADDI TT,(C)		;(Q)
	MOVSS TT
	HRRI TT,T
	.GETLOC TT,
	PUSHJ P,DIRNUM
DIRFR1:	AOBJN C,DIRFR0
	SUB P,[2,,2]
	PUSHJ P,DIRCLF
DIRHDE:	JRST DIRCLF
	
;;; Print one file
DIRFIL:	SKIPGE DATDRP(IDX)	;Anything left at all to do?
	 POPJ P,		;No
	SKIPE DATNDR(IDX)	;Initialized?
	 JRST DIRFL1
	PUSHJ P,DIRINI		;No, do so
	JRST DIRFIL

DIRFL1:	PUSHJ P,DIR1FL		;Directory of one file
	PUSHJ P,DIRNFL		;Step to next file
CPOP1J:	AOS (P)
	POPJ P,

DIRINI:	MOVE TT,DATSNM(IDX)	;Get directory requested
DIRIN1:	JUMPE TT,DIRSIM		;Simple case, no directory wildcards
	SETZ T,
	LSHC T,6
	CAIE T,'*		;A wildcard specifier?
	 JRST DIRIN1

;; The directory has some wildcards, figure out which ones to do
CNT==:1				;Temporary AC's for sort
LST==:2
DIRWLD:	SETO LST,		;LIST _ NIL
	SETZ CNT,		;COUNT _ 0
	SKIPA D,MFDBUF+MDNAMP
DIRWL1:	 ADDI D,LMNBLK
	CAIL D,2000
	 JRST DIRWL2		;End of MFD, go sort
	SKIPN TT,MFDBUF(D)
	 JRST DIRWL1
	MOVE B,DATSNM(IDX)
	PUSHJ P,DIRMAT		;Star match
	 JRST DIRWL1		;No good, try next
	MOVEM LST,MFDBUF+1(D)
	MOVEI LST,MFDBUF(D)	;LIST _ CONS(D,LIST)
	AOJA CNT,DIRWL1

;;; Attempt star matching, pattern in B, test in TT.  Clobbers A,T,TT
DIRMAT:	CAME B,[SIXBIT /*/]	;Just * matches all
DIRMT1:	 CAMN B,TT		;The same now?
	 JRST CPOP1J		;A winner
	SETZB A,T
	LSHC A,6
	LSHC T,6
	CAIE A,(T)		;Same character
	 CAIN A,'*		;Or * in patter
	 JRST DIRMT1		;Yes, go on
	POPJ P,			;No, a loser

;;; Have all the matching entries linked thru LST, sort them
DIRWST:	CAIN CNT,1		;At end of list?
	 JRST DRWSTR		;Yes, return it
	PUSH P,CNT		;Save count
	LSH CNT,-1
	PUSHJ P,DIRWST		;Recurse for first section
	POP P,CNT
	PUSH P,A		;Save value
	ADDI CNT,1
	LSH CNT,-1
	PUSHJ P,DIRWST		;Recurse for second section
	POP P,B			;Get first value
	MOVEI C,D-1		;Where to accumulate list

;; Merge two sublists
DIRWSM:	JUMPL B,DRWST1		;No first arg, maybe use second
	JUMPL A,DRWSTB		;No second, use first
	MOVE T,(A)		;Get second name
	MOVE TT,(B)		;Get first name
;; Do magnitude comparison
	JUMPL T,DRWSM2		;T neg?
	JUMPL TT,DRWSTA		;No, and TT neg => TT greater
	JRST DRWSMC		;Both pos, just compare

DRWSM2:	JUMPGE TT,DRWSTB	;T neg and TT pos => T greater
	EXCH T,TT		;Both negative, reverse comparison
DRWSMC:	CAML T,TT
	 JRST DRWSTA		;1st greater => take it

DRWSTB:	MOVEM B,1(C)
	MOVEI C,(B)
	MOVE B,1(C)
	JRST DIRWSM

DRWSTA:	MOVEM A,1(C)		;Enter 1st at head
	MOVEI C,(A)		;Transfer it to tail
	MOVE A,1(C)		;Get next one
	JRST DIRWSM		;And continue

DRWST1:	JUMPGE A,DRWSTA		;Use 2nd if any
	SETOM 1(C)
	MOVE A,D
	POPJ P,

DRWSTR:	MOVEI A,(LST)		;A _ CAR(LIST)
	MOVE LST,1(LST)		;LIST _ CDR(LIST)
	SETOM 1(A)		;RPLACD(A,NIL)
	POPJ P,			;RETURN(A)

;; Simple case, only one directory
DIRSIM:	SETOM DATNDR(IDX)	;Flag that there is no next directory
	MOVE A,DATSNM(IDX)
	JRST DIRMAP

DIRWL2:	SKIPL A,LST		;If there is anything there,
	 PUSHJ P,DIRWST		;sort it
	MOVEM A,DATNDR(IDX)	;DATNDR _ SORT(LIST)

;; Step to next directory
DIRNDR:	SKIPG A,DATNDR(IDX)	;Next directory link
	 JRST [	SETOM DATDRP(IDX)	;Flag that no files are left to do
		POPJ P,]	;Single return for no more
	MOVE T,1(A)
	MOVEM T,DATNDR(IDX)
	MOVE A,(A)		;Sixbit directory name

;; Start going on directory in A
DIRMAP:	MOVSI T,ST.ALD
	TDNE T,DATSTA(IDX)
	 JRST [	MOVEM A,DATFN1(IDX)	;Someplace to store directory name
		AOS DATDRP(IDX)
		POPJ P,]	;Directories only, skip mapping ufd
	PUSHJ P,GETUF1
	 JRST DIRDIE
	MOVE D,DIRBUF+UDNAMP	;Initialize pointer to first file
	JRST DIRNF1		;Then advance to next file

;;; Here if we can't get a directory.  Give an error over the connection and punt.
DIRDIE:	PUSH P,PKTLOC		;Direct data to the async packet
	MOVEI T,ASYPKT
	MOVEM T,PKTLOC
	MOVE A,DATSTA(IDX)
	HRRI A,ST%ASY		;Channel now in ASYNC-MARKED state
	TLO A,ST.UNC		;Not continuable
	MOVEM A,DATSTA(IDX)
	TRO F,F.FHN		;Force outputting of a file handle
	PUSHJ P,OPNERP
	PUSHJ P,ICCERP
	POP P,PKTLOC
	SETOM DATDRP(IDX)
	POPJ P,

;;; Map in directory in A
GETUFD:	MOVEI T,DIRBUF/2000	;Allocate space for directory mapping
	PUSHJ P,PAGALO
GETUF1:	.CALL [	SETZ
		SIXBIT /OPEN/
		%CLERR,,ERRCOD
		%CLBTW+%CLIMM,,.UII
		%CLIN,,DATCHN(IDX)
		%CLIN,,DATDEV(IDX)
		%CLIN,,[SIXBIT /.FILE./]
		%CLIN,,[SIXBIT /(DIR)/]
		%CLIN+%CLEND,,A]
	 POPJ P,
	MOVEI T,2000
	MOVE TT,[444400,,DIRBUF]
	.CALL [	SETZ
		SIXBIT /SIOT/
		%CLERR,,ERRCOD
		%CLIN,,DATCHN(IDX)
		%CLIN,,TT
		%CLIN+%CLEND,,T]
	 SETZM DIRBUF+UDNAME
	.CALL [	SETZ
		SIXBIT /CLOSE/
		%CLIN+%CLEND,,DATCHN(IDX)]
	 JFCL
	SKIPE DIRBUF+UDNAME
	 AOS (P)
	POPJ P,

;;; Step to next file
DIRNFL:	MOVE D,DATDRP(IDX)
	MOVSI T,ST.ALD
	TDNE T,DATSTA(IDX)
	 JRST [	JUMPE D,DIRNDR	;If directory already done, move to next
		POPJ P,]	;Else continue with it
DIRNF0:	ADDI D,LUNBLK
DIRNF1:	TLNE D,-1
	 HLRZS D		;D now points to next file to do
	CAIL D,2000		;Off the end?
	 JRST DIRNDR		;Yes, step to next directory
	MOVE B,DATFN1(IDX)	;Match FN1
	MOVE TT,DIRBUF+UNFN1(D)
	PUSHJ P,DIRMAT
	 JRST DIRNF0
	MOVS B,DATFN2(IDX)	;Newest or oldest version requested?
	CAIE B,(SIXBIT/</)
	 CAIN B,(SIXBIT/>/)
	  JRST DIRNF2
	MOVE B,DATFN2(IDX)	;Match FN2
	MOVE TT,DIRBUF+UNFN2(D)
	PUSHJ P,DIRMAT
	 JRST DIRNF0
DIRNF4:	MOVEM D,DATDRP(IDX)
	POPJ P,

;;; Next file when only want newest or oldest version of each file.
;;; We include every file with a non-numeric FN2, to be conservative.
;;; DATDRP(IDX) is either the index of the file, or the index
;;; of the next file group in the LH and garbage in the RH.
DIRNF2:	MOVE TT,DIRBUF+UNFN2(D)
	PUSHJ P,DIRNMP		;Is this a group of versions?
	 JRST DIRNF4		;No, just a single file
	MOVE A,DIRBUF+UNFN1(D)	;Yes, find end of the group
	MOVEI B,(D)
DIRNF3:	ADDI B,LUNBLK
	CAIGE B,2000
	 CAME A,DIRBUF+UNFN1(B)
	  JRST DIRNF5
	MOVE TT,DIRBUF+UNFN2(B)
	PUSHJ P,DIRNMP
	 CAIA
	  JRST DIRNF3
DIRNF5:	HRL D,B			;File to look at next time
	MOVS TT,DATFN2(IDX)	;Want oldest of these or newest?
	CAIN TT,(SIXBIT/>/)
	 SKIPA C,[CAMGE TT,A]
	  MOVE C,[CAMLE TT,A]
	MOVE A,DIRBUF+UNFN2(D)	;Get right-adjusted version of first file
	TRNN A,77
	 JUMPN A,[ LSH A,-6
		   JRST .-1 ]
	MOVEI T,(D)
DIRNF6:	ADDI T,LUNBLK
	CAIL T,(B)		;More versions in group?
	 JRST DIRNF4		;No, D points at best one found
	MOVE TT,DIRBUF+UNFN2(T)	;Get right-adjusted version of this file
	TRNN TT,77
	 JUMPN TT,[ LSH TT,-6
		    JRST .-1 ]
	XCT C			;Skip if TT is better than A
	 JRST DIRNF6		;A,D is still best version
	MOVE A,TT		;New best version
	HRRI D,(T)		;New file to put in dir listing
	JRST DIRNF6

;Skip if sixbit in TT is purely numeric
DIRNMP:	MOVEI T,0
	LSHC T,6
	CAIL T,'0
	 CAILE T,'9
	  POPJ P,
	JUMPN TT,DIRNMP
	JRST CPOPJ1	

;;; Process one file
DIR1FL:	MOVE A,DATDEV(IDX)
	PUSHJ P,DIRSXO
	MOVEI A,[ASCIZ \: \]
	PUSHJ P,DIRSTR
	MOVSI TT,ST.ALD
	TDNE TT,DATSTA(IDX)
	 JRST DIR1AD
	MOVE A,DIRBUF+UDNAME
	PUSHJ P,DIRSXO
	MOVEI A,[ASCIZ \; \]
	PUSHJ P,DIRSTR
	MOVE D,DATDRP(IDX)	;Get pointer to file
	MOVE A,DIRBUF+UNFN1(D)
	PUSHJ P,DIRSXO
	MOVEI BYTE,40
	PUSHJ P,DIRCHO
	MOVE A,DIRBUF+UNFN2(D)
	PUSHJ P,DIRSXO
	PUSHJ P,DIRCLF
	MOVSI TT,ST.FST
	TDNE TT,DATSTA(IDX)	;Fast option?
	 JRST DIR1FE		;Yes, skip rest
	MOVE T,DIRBUF+UNRNDM(D)
	TLNE T,UNLINK		;Is this file a link?
	 JRST DIR1LN		;Yes, special processing
	TLNN T,UNIGFL		;* file?
	 JRST DIR1F1		;No, ordinary
	MOVSI TT,ST.DEL
	TDNN TT,DATSTA(IDX)	;Listing deleted files?
	 POPJ P,		;No, skip this one
	MOVEI A,[ASCIZ \DELETED\]
	PUSHJ P,DIRSCL
DIR1F1:	TLNN T,UNREAP
	 JRST DIR1F2
	MOVEI A,[ASCIZ \DONT-REAP\]
	PUSHJ P,DIRSCL
DIR1F2:	TLNE T,UNDUMP
	 JRST DIR1F3
	MOVEI A,[ASCIZ \NOT-BACKED-UP\]
	PUSHJ P,DIRSCL
DIR1F3:	LDB T,[UNPKN DIRBUF+UNRNDM(D)]
	MOVEI A,[ASCIZ \PHYSICAL-VOLUME\]
	PUSHJ P,DIRDEC
	MOVEI T,2000*36.
	MOVEI A,[ASCIZ \BLOCK-SIZE\]
	PUSHJ P,DIRDEC
	PUSHJ P,DIRLN0		;Length in blocks into T
	PUSH P,T		;Save it
	MOVEI A,[ASCIZ \LENGTH-IN-BLOCKS\]
	PUSHJ P,DIRDEC
	POP P,T			;Length in blocks
	LDB TT,[UNWRDC DIRBUF+UNRNDM(D)]	;Word count of last block
	SKIPE TT
	 SUBI T,1
	LSH T,10.
	ADDI T,(TT)		;Word count now in T
	PUSH P,T
	LDB T,[UNBYTE DIRBUF+UNREF(D)]	;Byte size info
	TRZE T,400
	 JRST [	IDIVI T,100	;400+100xS+C
		JRST DIR1F4]
	TRZE T,200
	 JRST [	IDIVI T,20	;200+20xS+C
		JRST DIR1F4]
	SUBI T,36.
	 JUMPGE T,[IDIVI T,4	;44+4xS+C
		   JRST DIR1F4]
	MOVMS T			;44-S
	SETZ TT,		;C=0
DIR1F4:	PUSH P,TT		;Save number of extra bytes
	PUSH P,T		;Save byte size
	MOVEI A,[ASCIZ \BYTE-SIZE\]
	PUSHJ P,DIRDEC
	MOVEI T,36.
	IDIV T,(P)		;Number of words per byte
	IMUL T,-2(P)		;Times number of words
	SUB T,-1(P)		;Less number of extra bytes
	SUB P,[3,,3]
	MOVEI A,[ASCIZ \LENGTH-IN-BYTES\]
	PUSHJ P,DIRDEC

DIR1FD:	MOVE T,DIRBUF+UNDATE(D)
	MOVEI A,[ASCIZ \CREATION-DATE\]
	PUSHJ P,DIRDTO
	HLLZ T,DIRBUF+UNREF(D)
	MOVEI A,[ASCIZ \REFERENCE-DATE\]
	PUSHJ P,DIRDTO
	LDB T,[UNAUTH DIRBUF+UNREF(D)]
	CAIN T,777		;No author?
	 JRST DIR1FE
	SUB T,MFDBUF+MDNUDS
	ASH T,1
	SKIPN T,MFDBUF+2000(T)	;Get sixbit directory name
	 JRST DIR1FE
	MOVEI A,[ASCIZ \AUTHOR\]
	PUSHJ P,DIRIND
	MOVE A,T
	PUSHJ P,DIRSXO
	PUSHJ P,DIRCLF
DIR1FE:	JRST DIRCLF

;; Link info output
DIR1LN:	MOVEI A,[ASCIZ \LINK-TO\]
	PUSHJ P,DIRIND
	PUSHJ P,DIRDSC		;Get link descriptor
	PUSHJ P,DIRLXO
	MOVEI BYTE,";
	PUSHJ P,DIRCHO
	MOVEI BYTE,40
	PUSHJ P,DIRCHO
	PUSHJ P,DIRLXO
	MOVEI BYTE,40
	PUSHJ P,DIRCHO
	PUSHJ P,DIRLXO
	PUSHJ P,DIRCLF
	JRST DIR1FD		;Return to main body

;;; Output link atom  b.p. in A
DIRLXO:	MOVEI T,6		;End on six characters
DIRLX0:	ILDB BYTE,A
	JUMPE BYTE,CPOPJ
	CAIN BYTE,';		; ; ends
	 POPJ P,
	CAIN BYTE,':		; : quotes
	 ILDB BYTE,A
	ADDI BYTE,40
	PUSHJ P,DIRCHO
	SOJG T,DIRLX0
	POPJ P,

;;; Get length in blocks into T
DIRLN0:	PUSHJ P,DIRDSC		;Get ufd descriptor
	MOVEI T,0
DIRLN1:	ILDB B,A
	JUMPE B,CPOPJ		;End by 0
	CAILE B,UDTKMX		;1-UDTKMX
	 JRST DIRLN2
	ADDI T,(B)		;Take N
	JRST DIRLN1

DIRLN2:	CAIGE B,UDWPH
	 AOJA T,DIRLN1		;Take 1
	CAIN B,UDWPH		;Write place holder
	 JRST DIRLN1
	IBP A
	IBP A
	AOJA T,DIRLN1

;;; Get file descriptor into A.  Clobbers B
DIRDSC:	LDB A,[UNDSCP DIRBUF+UNRNDM(D)]	;Get link descriptor
	IDIVI A,UFDBPW
	ADD A,[	440600,,DIRBUF+UDDESC
		360600,,DIRBUF+UDDESC
		300600,,DIRBUF+UDDESC
		220600,,DIRBUF+UDDESC
		140600,,DIRBUF+UDDESC
		060600,,DIRBUF+UDDESC](B)
	POPJ P,

;;; Directory output, device already output.
;;; DATDRP is the directory name while it is pending, 0 while waiting for the next one.
DIR1AD:	MOVE A,DATFN1(IDX)
	PUSHJ P,DIRSXO
	MOVEI A,[ASCIZ \; \]
	PUSHJ P,DIRSTR
	PUSHJ P,DIRCLF
	PUSHJ P,DIRCLF
	SETZM DATDRP(IDX)
	POPJ P,

;;; SIXBIT output from A
DIRSXO:	MOVE B,A
DIRSO0:	JUMPE B,CPOPJ
	SETZ A,
	LSHC A,6
	JUMPE A,DIRSOQ
	CAIE A,':
	 CAIN A,';
	 JRST DIRSOQ
DIRSO1:	MOVEI BYTE,40(A)
	PUSHJ P,DIRCHO
	JRST DIRSO0

DIRSOQ:	MOVEI BYTE,"
	PUSHJ P,DIRCHO
	JRST DIRSO1

;;; Output date in T with indicator in A
DIRDTO:	PUSHJ P,DIRIND
	PUSHJ P,DIRDT0
	JRST DIRCLF

DIRDT0:	CAMN T,[-1]
	MOVEI T,0
	PUSH P,T
	MOVEI B,10.		;Numbers are decimal
	LDB T,[UNMON (P)]
	PUSHJ P,DIRDNM
	MOVEI BYTE,"/
	PUSHJ P,DIRCHO
	LDB T,[UNDAY (P)]
	PUSHJ P,DIRDNM
	MOVEI BYTE,"/
	PUSHJ P,DIRCHO
	LDB T,[UNYRB (P)]
	PUSHJ P,DIRDNM
	HRRZ T,(P)
	JUMPE T,DIRDT1
	MOVEI BYTE,40
	PUSHJ P,DIRCHO
	LSH T,-1
	IDIVI T,60.
	PUSH P,TT
	IDIVI T,60.
	PUSH P,TT
REPEAT 3,[
	PUSHJ P,DIRDNM
IFN .RPCNT-2,[
	MOVEI BYTE,":
	PUSHJ P,DIRCHO
	POP P,T
]	;END IFN
]	;END REPEAT
DIRDT1:	POP P,T
	POPJ P,
]	;END IFN ITS

;; Simple two/three digit printer with leading zero
;; Dates are not supposed to have three digits, but they get them sometimes from someplace
;; and this is what :FIND does.
DIRDNM:	IDIVI T,100.
	EXCH T,TT
	JUMPE TT,.+3
	MOVEI BYTE,"0(TT)
	PUSHJ P,DIRCHO	
	IDIVI T,10.
	MOVEI BYTE,"0(T)
	PUSHJ P,DIRCHO
	MOVEI BYTE,"0(TT)
	JRST DIRCHO

IFN TNX,[
DIRHED:	PUSHJ P,DIRCLF		;Empty pathname for special information
	MOVSI TT,ST.FST\ST.ALD
	TDNE TT,DATSTA(IDX)	;Fast option?
	 JRST DIRHDE		;Yes, skip rest of heading
	MOVEI A,[ASCIZ \SETTABLE-PROPERTIES DONT-REAP NOT-BACKED-UP AUTHOR CREATION-DATE REFERENCE-DATE BYTE-SIZE LENGTH-IN-BYTES PROTECTION GENERATION-RETENTION-COUNT ACCOUNT TEMPORARY DELETED DONT-DELETE\]
	PUSHJ P,DIRSCL
DIRHDE:	PUSHJ P,DIRCLF
	AOS DATNDR(IDX)
	POPJ P,

DIRFIL:	SKIPN DATJFN(IDX)	;Still have a file?
	 POPJ P,		;No, cannot fill in anything
	MOVSI TT,ST.ALD
	TDNE TT,DATSTA(IDX)
	 JRST DIRALD
	HRROI 1,RESBLK
	HRRZ 2,DATJFN(IDX)
	MOVE 3,[111110,,JS%PAF]
	JFNS
	PUSHJ P,DIRRES
	PUSHJ P,DIRCLF
	MOVSI TT,ST.FST
	TDNE TT,DATSTA(IDX)	;Fast option?
	 JRST DIRFLE		;Yes, skip rest
	HRRZ 1,DATJFN(IDX)
	MOVSI 2,.FBUSW+1
	MOVEI 3,DIRINF
	GTFDB
	 ERJMP JSYSER
	MOVE T,DIRINF+.FBCTL	;Get control bits
	MOVSI TT,-NDBITS
DIRFLL:	TDNN T,DIRBIT(TT)
	 JRST DIRFL1
	MOVE A,DIRBST(TT)
	PUSHJ P,DIRSCL
DIRFL1:	AOBJN TT,DIRFLL	
	HRRZ T,DIRINF+.FBPRT
	MOVEI A,[ASCIZ \PROTECTION\]
	PUSHJ P,DIROCT
	LDB T,[<.BP FB%RET> DIRINF+.FBBYV]
	MOVEI A,[ASCIZ \GENERATION-RETENTION-COUNT\]
	PUSHJ P,DIRDEC
	LDB T,[<.BP FB%BSZ> DIRINF+.FBBYV]
	MOVEI A,[ASCIZ \BYTE-SIZE\]
	PUSHJ P,DIRDEC
	MOVE T,DIRINF+.FBSIZ
	MOVEI A,[ASCIZ \LENGTH-IN-BYTES\]
	PUSHJ P,DIRDEC
	MOVEI T,1000*36.
	MOVEI A,[ASCIZ \BLOCK-SIZE\]
	PUSHJ P,DIRDEC
	LDB T,[<.BP FB%PGC> DIRINF+.FBBYV]
	MOVEI A,[ASCIZ \LENGTH-IN-BLOCKS\]
	PUSHJ P,DIRDEC
	MOVE T,DIRINF+.FBWRT	;Really time of last write
	MOVEI A,[ASCIZ \CREATION-DATE\]
	PUSHJ P,DIRDAT
	MOVEI A,[ASCIZ \REFERENCE-DATE\]
	SKIPE T,DIRINF+.FBREF
	 PUSHJ P,DIRDAT
	MOVEI A,[ASCIZ \NOT-BACKED-UP\]
	SKIPN DIRINF+.FBBK0
	 PUSHJ P,DIRSCL
	MOVSI T,(AR%NAR)
	MOVEI A,[ASCIZ \DONT-REAP\]
	TDNE T,DIRINF+.FBBBT
	 PUSHJ P,DIRSCL
	HRRZ 1,DATJFN(IDX)
IFN 20X,[
	HRLI 1,.GFLWR		;Really last writer
	HRROI 2,RESBLK
	GFUST
	MOVEI A,[ASCIZ \AUTHOR\]
	PUSHJ P,DIRRCL
]
IFN 10X,[
	HRROI 1,RESBLK
	HLRZ 2,DIRINF+.FBUSE	;Author
	DIRST
	 JRST .+3
	MOVEI A,[ASCIZ \AUTHOR\]
	PUSHJ P,DIRRCL
	HRROI 1,RESBLK
	HRRZ 2,DIRINF+.FBUSE	;Last reader
	DIRST
	 JRST .+3
	MOVEI A,[ASCIZ \READER\]
	PUSHJ P,DIRRCL
]
	HRROI 1,RESBLK
	HRRZ 2,DATJFN(IDX)
	MOVEI 3,JS%ACT
	JFNS
	MOVEI A,[ASCIZ \ACCOUNT\]
	PUSHJ P,DIRRCL

;; Done with this file, output blank line
DIRFLE:	MOVE 1,DATJFN(IDX)
	GNJFN
	 SETZM DATJFN(IDX)
DIRFE1:	PUSHJ P,DIRCLF
	AOS DATNDR(IDX)
CPOP1J:	AOS (P)			;Skip return for full file
	POPJ P,	

DIRALD:	SKIPE 2,DATDRN(IDX)	;Have a directory number already?
	 JRST DIRAL1
	PUSHJ P,DIRSTP
	 POPJ P,
DIRAL1:	HRROI 1,RESBLK
	DIRST
	 JRST DIRAL2
IFN 10X,[
	MOVEI A,[ASCIZ /DSK:</]	;>
	PUSHJ P,DIRSTR
];10X
	MOVEI A,RESBLK
	PUSHJ P,DIRSTR
IFN 10X,[			;<
	MOVEI BYTE,">
	PUSHJ P,DIRCHO
];10X
	PUSHJ P,DIRCLF
DIRAL2:	PUSHJ P,DIRSTP
	 SETZM DATDRN(IDX)
	JRST DIRFE1

DIRSTP:	HRROI 1,RESBLK
	MOVE 2,DATJFN(IDX)
IFN 10X,MOVSI 3,(JS%DIR)
.ELSE	MOVE 3,[JS%DEV+JS%DIR+JS%PAF]
	JFNS
	MOVSI 1,(RC%AWL)
	HRROI 2,RESBLK
	SKIPE 3,DATDRN(IDX)
	 TLO 1,(RC%STP)
	RCDIR
	MOVEM 3,DATDRN(IDX)
	MOVE 2,3		;Return in 2
	TLNN 1,(RC%NMD\RC%NOM)
	 JRST CPOP1J
	MOVE 1,DATJFN(IDX)
	RLJFN
	 JFCL
	SETZM 1,DATJFN(IDX)
	POPJ P,

DIRBIT:	FB%TMP
	FB%DEL
IFN 20X,[
	FB%DIR
	FB%NOD
	FB%OFF
	FB%UND
];20X
.ELSE	400,,0
NDBITS==:.-DIRBIT

DIRBST:	[ASCIZ \TEMPORARY\]
	[ASCIZ \DELETED\]
IFN 20X,[
	[ASCIZ \DIRECTORY\]
	[ASCIZ \DONT-DUMP\]
	[ASCIZ \OFFLINE\]
];20X
	[ASCIZ \DONT-DELETE\]

;;; Output date in T
DIRDAT:	HRROI 1,RESBLK
	MOVE 2,T
	SETZ 3,
	ODTIM

;;; Output string in A, then RESBLK, then newline
DIRRCL:	PUSHJ P,DIRIND
	PUSHJ P,DIRRES
	JRST DIRCLF
]	;END IFN TNX

;;; Output indicator
DIRIND:	PUSHJ P,DIRSTR
	MOVEI BYTE,40
	JRST DIRCHO

;;; Output octal number in T for property indicator in A
;;; NOTE: This function knows about returning from its caller
DIROCT:	SKIPA B,[8]
DIRDEC:	 MOVEI B,10.
	PUSHJ P,DIRIND
	PUSHJ P,DIRNUM
	JRST DIRCLF

;;; Just output number in T base in B
DIRNUM: PUSH P,[-1]
DIRNM0:	IDIVI T,(B)
	PUSH P,TT
	JUMPN T,DIRNM0
DIRNM1:	POP P,BYTE
	JUMPL BYTE,CPOPJ
	ADDI BYTE,"0
	PUSHJ P,DIRCHO
	JRST DIRNM1

DIRSCL:	PUSHJ P,DIRSTR
DIRCLF:	MOVEI A,[.BYTE 7 ? 15 ? 12]
	JRST DIRSTR

IFN TNX,DIRRES: SKIPA A,[440700,,RESBLK]
DIRSTR:	HRLI A,440700
DIRST1:	ILDB BYTE,A		;Get next character
	JUMPE BYTE,CPOPJ	;Terminate on null
	PUSHJ P,DIRCHO
	JRST DIRST1

DIRCHO:	SOJLE BC,REDBF1		;Unwind when buffer filled
	IDPB BYTE,BP
	POPJ P,

;;; Filename completion command
COMCPL:	SKIPN USERID
	 CERR NLI,[NOT LOGGED IN]
	SETZ D,			;Clear options here
CPLOPT:	TRNE F,F.NWL		;End of options?
	 JRST CPLFNM
	PUSHJ P,COMRD5		;Get token
	 JUMPL BC,COMBAD
CPLOLP:	MOVEI T,CPLLEN-1
CPLOL1:	CAME A,CPLTAB(T)
	 SOJGE T,CPLOL1
	JUMPL T,[CERR UCO,[UNKNOWN COMPLETE OPTION]]
	XCT CPLACT(T)
	 JRST COMBAD
	JRST CPLOPT

CPLTAB:	ASCII \DELET\
	ASCII \READ\
	ASCII \WRITE\
	ASCII \OLD\
	ASCII \NEW-O\
CPLLEN==.-CPLTAB

CPLACT: TLOA D,ST.DEL
	TLZA D,ST.OUT
	TLOA D,ST.OUT
	TLZA D,ST.NOK
	TLOA D,ST.NOK

IFN TNX,[
;;; Local storage
DEFDEV==RESBLK
DEFDIR==DEFDEV+1
DEFNAM==DEFDIR+1
DEFTYP==DEFNAM+1
DEFSTR==DEFTYP+1

;Parse only GTJFN doesn't quite work on Tenex
;So, if we get no such device or no such directory, flush that all together and
;hope the system defaults help.
IFN 10X,[
CPLFIX:	MOVEI BYTE,215
	DPB BYTE,BP		;Put back old end of line
	MOVE BP,3		;Get old byte pointer
	MOVE BC,4
CPLFX1:	SOJL BC,JSYSER
	ILDB BYTE,BP
	JUMPE BYTE,JSYSER	;End and no special character
	CAIN BYTE,^V
	 JRST [	IBP BP
		SOJA BC,CPLFX1]
	CAIE BYTE,(1)		;One we want
	 JRST CPLFX1
]

CPLFNM:
IFN 10X,MOVE 3,BP		;Save current byte pointer
.ALSO	MOVE 4,BC
	TLO D,ST.PON
	PUSHJ P,COMGJF		;Get JFN for default
IFE 10X, JRST JSYSER
.ELSE [	 JRST [	CAIN 1,GJFX16	;No such device
		 JRST [	MOVEI 1,":
			JRST CPLFIX]
		CAIN 1,GJFX17	;No such directory <
		 JRST [	MOVEI 1,">
			JRST CPLFIX]
		JRST JSYSER]	;Else real error
];10X
	MOVE 2,1		;Setup for JFNS
	MOVEI 1,DEFSTR		;Some string space
	SETZ A,
IRPS STR,,[DEV DIR NAM TYP]
	HRROI 1,1(1)
	MOVEM 1,DEF!STR
	MOVSI 3,(JS%!STR)
	JFNS
	IDPB A,1
TERMIN
	HRROI 1,1(1)
	PUSH P,1
	MOVSI 3,(JS%GEN)
	JFNS
	POP P,1
	HRLI 1,440700
	ILDB 1,1
	CAIN 1,"*
	 TLO D,ST.DIR		;Remember if should have wild default
	MOVE 1,2
	RLJFN			;Done with this JFN
	 JFCL
	SETZM GTJBLK
	MOVE A,[GTJBLK,,GTJBLK+1]
	BLT A,GTJBLK+.GJBFP	;Clear out long call GTJFN block
	MOVEM BP,DEFSTR		;Save user's string
	PUSHJ P,COMEUS		;Find end of it
	 JRST [TRZN F,F.NWL	;Must be terminated with a newline
	        JRST COMBAD
	       JRST .+2]
	  JRST .-2		;Terminated by space, so keep searching
	MOVEI 1,33		;Put in escape to get completion
	DPB 1,BP
	SETZ 1,
	IDPB 1,BP

;;; Now have defaults and user's string.  If this is an input file, the idea is to
;;; keep trying GTJFN without allowing new files and various default conditions
;;; until we manage to win.
	TLNN D,ST.OUT
	 SKIPA C,[-NCPLMT,,CPLMTH]	;Completion method routines
	 HRROI C,CPLOUT		;Completion for output
	TLNN D,ST.NOK		;New file ok?
	 ADD C,[1,,0]		;No, skip last method

;;; Here to try next method
CPLLUP:.GJTYP==.GJEXT			;Nothing is consistent
IRPS STR,,[DEV DIR NAM TYP]
	MOVE 1,DEF!STR
	MOVEM 1,GTJBLK+.GJ!STR
TERMIN
	MOVE 1,[.NULIO,,.NULIO]
	MOVEM 1,GTJBLK+.GJSRC
	MOVEI 1,2		;Two extra words
	MOVEM 1,GTJBLK+.GJF2
	HRROI 1,JFNSTR
	MOVEM 1,GTJBLK+.GJCPP
	MOVEI 1,30.*5
	MOVEM 1,GTJBLK+.GJCPC
	MOVSI 1,(GJ%OLD\GJ%FLG\GJ%XTN)
	TLNE D,ST.DEL
	 TLO 1,(GJ%DEL)
	TLNE D,ST.DIR
	 IOR 1,[GJ%IFG+.GJALL]
	XCT (C)
	MOVEM 1,GTJBLK+.GJGEN
	MOVEI 1,GTJBLK
	MOVE 2,DEFSTR
	GTJFN
	 JRST CPLNXT		;Failed, try next method
	MOVE 3,[111110,,JS%PAF]	;Device, directory, filename, file type, version

;;; Now, if the user didn't really type the generation number, don't give it back
	SKIPL GTJBLK+.GJGEN	;GJ%FOU supplied?
	 JRST [	TLNE 1,(GJ%UHV)	;No, highest existing = 0
		 JRST .+2
		JRST .+3]
	TLNE 1,(GJ%NHV)		;Yes, next higher = 0
	 TLZ 3,(JS%GEN)
	MOVE 2,1		;Jfn
	HRROI 1,JFNSTR
	JFNS
	MOVE 1,2
	RLJFN
	 JFCL
	MOVEI A,[ASCIZ \OLD\]
	MOVSI 1,(GJ%OLD)
	TDNN 1,GTJBLK+.GJGEN
	 MOVEI A,[ASCIZ \NEW\]
	JRST CPLDON

CPLNXT:	AOBJN C,CPLLUP		;Keep trying and finally return typescript as is
	LDB 1,GTJBLK+.GJCPP
	SETZ 2,
	CAIN 1,33		;Clear altmode from user's typescript
	 DPB 2,GTJBLK+.GJCPP
	MOVEI A,[ASCIZ \NIL\]
CPLDON:	PUSH P,A
	MOVEI A,[ASCIZ \COMPLETE \]
	PUSHJ P,COMCTL
	POP P,A
	PUSHJ P,COMSTO
	MOVEI BYTE,215
	PUSHJ P,COMCHO
	MOVEI A,JFNSTR
	PUSHJ P,COMSTO
	MOVEI BYTE,215
	PUSHJ P,COMCHO
	PUSHJ P,COMSND
	JRST CTLLOP

CPLMTH:	JFCL
	SETZM GTJBLK+.GJEXT
	SETZM GTJBLK+.GJNAM
	PUSHJ P,CPLNBT
	TLZ 1,(GJ%OLD)
NCPLMT==.-CPLMTH

CPLOUT:	TLC 1,(GJ%FOU\GJ%OLD\GJ%NEW)

CPLNBT:	SETZM GTJBLK+.GJNAM
	SETZM GTJBLK+.GJEXT
	POPJ P,

];END OF COMPLETION COMMAND FOR TNX

IFN ITS,[
;;; ITS COMPLETION COMMAND

CPLFNM:	MOVEI IDX,MAXIDX	;Use probe variables for filename parsing etc.
	HLLM D,DATSTA(IDX)	;Save status bits
	SETZM DATSNM(IDX)
	SETZM DATFN2(IDX)
	PUSHJ P,COMPFN		;Parse the filename spec for the default
	IRPS SYL,,[SNM FN1 FN2]
	 MOVE TT,DAT!SYL(IDX)	;Save the defaults
	 MOVEM TT,DEF!SYL'
	 TERMIN
	SETZM DATSNM(IDX)
	SETZM DATFN2(IDX)
	PUSHJ P,COMPFN		;Parse the user's string
	PUSHJ P,LCKDIR		;Get DIRLCK
	;; First, find the directory
	SKIPN A,DATSNM(IDX)	;Start from any specified directory
	 MOVE A,DEFSNM		;None, start from default
	SKIPN A
	 MOVE A,HSNAME		;If no default, use default default: user's homedir
	PUSHJ P,GETUFD		;Read in the directory
	 CAIA
	  JRST CPLFN3
	;; Directory doesn't exist, try completion on it
	PUSHJ P,GETMFD		;Read in the MFD
	 JRST CPLFN9		;Can't do much without any dirs
	PUSHJ P,CMPLT0
	SKIPA D,MFDBUF+MDNAMP
CPLFN1:	 ADDI D,LMNBLK
	CAIL D,2000
	 JRST CPLFN2
	MOVE A,MFDBUF(D)
	PUSHJ P,CMPLT1
	JRST CPLFN1

CPLFN2:	MOVE A,CMPLTW		;Result of directory completion
	MOVEM A,DATSNM(IDX)	;Return it whether or not directory exists
	PUSHJ P,GETUFD
	 JRST CPLFN9		;Directory doesn't exist, stop now
CPLFN3: MOVEM A,DATSNM(IDX)
	;; Now scan the directory.  First we plug in the defaults and complete.
	;; If that yields an existent file, or this is for output, take that as
	;; the result.  Otherwise complete without plugging in the defaults.
	;; If that yields an existent file, take it.  Otherwise take the results
	;; of plugging in the defaults and completing if new-file is okay.
	;; We don't distinguish defaulting FN1 and defaulting FN2.
	SKIPN A,DATFN1(IDX)
	 MOVE A,DEFFN1
	SKIPN B,DATFN2(IDX)
	 JRST [	MOVE B,DEFFN2	;Note, never take ">" from the defaults
		CAMN B,[SIXBIT/>/]
		 SETZ B,
		JRST .+1 ]
	PUSHJ P,CPLDIR
	 JRST [	MOVSI T,ST.OUT	;No existent file, doing output?
		TDNN T,DATSTA(IDX)
		 JRST CPLFN4	;No, try without defaults
		JRST CPLFN7 ]	;Matches non-existent file
	JRST CPLFN7		;Matches possibly-existent file

CPLFN4:	PUSH P,A		;Save results of completion with default
	PUSH P,B
	MOVE A,DATFN1(IDX)	;Try again without defaults
	MOVE B,DATFN2(IDX)
	PUSHJ P,CPLDIR
	 JRST [	MOVSI T,ST.NOK	;That didn't work either, new file okay?
		TDNN T,DATSTA(IDX)
		 JRST CPLFN9	;No, no completions found
		POP P,B		;Yes, take the completion-with-defaults
		POP P,A
		JRST .+2 ]
	 SUB P,[2,,2]
; A and B now have the result of the completion.  Determine NEW/OLD status.
CPLFN7:	MOVEM A,DATFN1(IDX)
	MOVEM B,DATFN2(IDX)
	SKIPA D,DIRBUF+UDNAMP	;See if completed file really exists
CPLF7A:	 ADDI D,LUNBLK
	CAIL D,2000
	 JRST CPLF7B
	CAME A,DIRBUF+UNFN1(D)
	 JRST CPLF7A
	CAMN B,DIRBUF+UNFN2(D)
	 JRST CPLF7C
	JUMPE B,CPLF7C		;The file exists
	CAME B,[SIXBIT/>/]
	 CAMN B,[SIXBIT/</]
	  JRST CPLF7C
	JRST CPLF7A	

CPLF7B:	SKIPA A,[[ASCIZ/NEW/]]
CPLF7C:	 MOVEI A,[ASCIZ/OLD/]
	JRST CPLDON

;Failure return
CPLFN9:	MOVEI A,[ASCIZ/NIL/]
CPLDON:	PUSH P,A
	MOVEI T,MFDBUF/2000
	PUSHJ P,PAGDAL
	MOVEI T,DIRBUF/2000
	PUSHJ P,PAGDAL
	SETZM DIRLCK
	MOVEI A,[ASCIZ \COMPLETE \]
	PUSHJ P,COMCTL
	POP P,A
	PUSHJ P,COMSTO
	MOVEI BYTE,215
	PUSHJ P,COMCHO
	PUSHJ P,COMRF1		;Read back completed file name (sans host)
	MOVEI BYTE,215
	PUSHJ P,COMCHO
	PUSHJ P,COMSND
	JRST CTLLOP

;Complete A and B against the directory in DIRBUF, return results in A and B
;Skip-return if any completions found
;Note that cannot complete FO BA to FOO BAR if FORD 1 also exists, i.e.
;it completes the two filenames separately.  Hopefully this is all right,
;although the Lisp machine completing reader is smarter.
;No attempt to do binary search although system has sorted the dir.
CPLDIR: PUSHJ P,CMPLT0		;Start completing FN1
	SKIPA D,DIRBUF+UDNAMP
CPLDR1:	 ADDI D,LUNBLK
	CAIL D,2000
	 JRST CPLDR2
	MOVE A,DIRBUF+UNFN1(D)
	PUSHJ P,CMPLT1
	JRST CPLDR1

CPLDR2:	MOVE C,CMPLTW		;Completed FN1
	SKIPGE CMPLTF		;Any completions found?
	 JRST CPLDR5		;Nope
	CAME B,[SIXBIT/>/]	;FN2 of < or > always matches
	 CAMN B,[SIXBIT/</]
	  JRST CPLDR5
	MOVE A,B		;Start completing FN2 against files with that FN1
	PUSHJ P,CMPLT0
	SKIPA D,DIRBUF+UDNAMP
CPLDR3:	 ADDI D,LUNBLK
	CAIL D,2000
	 JRST CPLDR4
	MOVE A,DIRBUF+UNFN2(D)
	CAMN C,DIRBUF+UNFN1(D)
	 PUSHJ P,CMPLT1
	JRST CPLDR3

CPLDR4:	JUMPN B,CPLDR6		;When completing a blank FN2, special hair
	SKIPE CMPLTF		;Exactly one match?
	 JRST CPLDR5		;No, result remains blank (i.e. ">")
	MOVE B,CMPLTW		;Yes, is it all numeric?
CPLDR7:	MOVEI A,0		;If so, we won't count it since it's a version not a type
	LSHC A,6
	CAIL A,'0
	 CAILE A,'9
	  JRST CPLDR6		;Blank FN2 matches a single filetype
	JUMPN B,CPLDR7
	TDZA B,B		;Result remains blank
CPLDR6:	 MOVE B,CMPLTW		;Completed FN2
CPLDR5:	MOVE A,C		;Completed FN1
	SKIPL CMPLTF		;Any completions found?
	 AOS (P)		;Yes, take skip return
	POPJ P,

CMPLTA==CLODAT			;Trying to keep the impure down to one page
CMPLTM==CLOLEN

;;; Completion of sixbit words
;;; Set up to complete the word in A
;;; After calling this, call CMPLT1 any number of times then pick
;;; up your result out of CMPLTW, which is either the original argument
;;; (in which case CMPLTF is negative), or else is the shortest existent
;;; extension of that.
CMPLT0:	MOVEM A,CMPLTA		;Word to match
	SETO T,
	TDNE A,T
	 JRST [	LSH T,-6
		JRST .-1 ]
	SETCAM T,CMPLTM		;Mask for fixed characters
	SETOM CMPLTF'		;No completions found yet
	MOVEM A,CMPLTW'		;Word found so far (result of completion)
	SETCAM T,CMPLTX'	;Mask for valid characters in that
	POPJ P,

;;; Use the sixbit in A as a possible completion.
CMPLT1:	MOVE TT,A
	XOR TT,CMPLTA
	TDNE TT,CMPLTM		;Does it match the fixed characters?
	 POPJ P,		;No.
	AOSE CMPLTF		;First completion found?
	 JRST CMPLT2		;No
	MOVEM A,CMPLTW		;Yes, save as result
	SETO T,			;and compute its length
	TDNE A,T
	 JRST [	LSH T,-6
		JRST .-1 ]
	SETCAM T,CMPLTX
	POPJ P,

CMPLT2:	MOVE TT,A		;Two completions, take their common prefix
	XOR TT,CMPLTW
	MOVE T,CMPLTX
	TDNE TT,T
	 JRST [	LSH T,6
		JRST .-1 ]
	MOVEM T,CMPLTX
	ANDM T,CMPLTW
	POPJ P,
];ITS

;;; Property changing command
COMCNG:	SKIPN USERID
	 CERR NLI,[NOT LOGGED IN]
	TRZN F,F.NWL		;Should be newline
	 JRST COMBAD
	TRNN F,F.FHN		;Use an open file?
	 JRST CNGFIL		;Nope, need a filename
	PUSHJ P,CNGLOP
	JRST CNGDN1

CNGFIL:	MOVEI IDX,MAXIDX	;Use dummy IDX
IFN ITS,[
	PUSHJ P,COMPFN
	.CALL [ SETZ
		SIXBIT /OPEN/
		%CLERR,,ERRCOD
		%CLBIT,,.UAI
		%CLIN,,DATCHN(IDX)
		%CLIN,,DATDEV(IDX)
		%CLIN,,DATFN1(IDX)
		%CLIN,,DATFN2(IDX)
		%CLIN+%CLEND,,DATSNM(IDX)]
	 JRST OPNERR
]
IFN TNX,[
	MOVSI D,ST.DEL
	PUSHJ P,COMGJF
	 JRST JSYSER
	MOVEM 1,DATJFN(IDX)	;Save jfn
]
	PUSHJ P,CNGLOP

;;; Done changing things, close the file, etc.
CNGDON:
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /CLOSE/
		%CLIN+%CLEND,,DATCHN(IDX)]
	 JFCL
]
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	RLJFN
	 JFCL
]
CNGDN1:	MOVEI A,[ASCIZ \CHANGE-PROPERTIES\]
	PUSHJ P,COMCTL
	PUSHJ P,COMSND
	JRST CTLLOP

CNGLOP:	JUMPLE BC,CPOPJ		;Done when end or just blank line
	TRZ F,F.NWL
	PUSHJ P,COMR10		;Get property name
	 JRST COMBAD
CNGOLP:	MOVEI C,CNGLEN
CNGOL1:	SOJL C,[CERR UCO,[UNKNOWN CHANGE OPTION]]
	CAMN A,CNGTAB-1(C)
	 CAME B,CNGTAB(C)
	 SOJA C,CNGOL1
	HRRZ T,CNGACT(C)	;Get routine
	PUSHJ P,(T)
	JRST CNGLOP

;;; NOTE: If you change this, be sure to update the list of settable properties at
;;; the start of DIRHED.
CNGTAB:	ASCII \DONT-REAP\	;DONT-REAP
	ASCII \NOT-BACKED\	;NOT-BACKED-UP
	ASCII \AUTHOR\		;AUTHOR
	ASCII \CREATION-D\	;CREATION-DATE
	ASCII \REFERENCE-\	;REFERENCE-DATE
IFN TNX,[
	ASCII \BYTE-SIZE\	;BYTE-SIZE
	ASCII \LENGTH-IN-\	;LENGTH-IN-BYTES
	ASCII \PROTECTION\	;PROTECTION
	ASCII \GENERATION\	;GENERATION-RETENTION-COUNT
	ASCII \ACCOUNT\		;ACCOUNT
	ASCII \TEMPORARY\	;TEMPORARY
	ASCII \DELETED\		;DELETED
	ASCII \DONT-DELET\	;DONT-DELETE
]
CNGLEN==.-CNGTAB

IFN ITS,[
CNGACT:	SIXBIT /SREAPB/ ? -1,,CNGBIT	;DONT-REAP
	SIXBIT /SDMPBT/ ? 0,,CNGBIT	;NOT-BACKED-UP
	SIXBIT /SAUTH/ ? CNGAUT		;AUTHOR
	SIXBIT /SFDATE/ ? CNGDAT	;CREATION-DATE
	SIXBIT /SRDATE/ ? CNGDAT	;REFERENCE-DATE

CNGBIT:	HLRE A,CNGACT(C)
	PUSH P,A		;Get sense of boolean
	PUSHJ P,COMRD5
	 JFCL
	CAMN A,[ASCII /NIL/]
	 SETCMM (P)
	POP P,A

;; Perfor system call for this routine, argument in A
CNGCAL:	MOVE B,CNGACT-1(C)
	.CALL [	SETZ
		SIXBIT /CALL/
		%CLERR,,ERRCOD
		%CLIN,,B
		%CLIN,,DATCHN(IDX)
		%CLIN+%CLEND,,A]
	 JRST COMFER
	POPJ P,

CNGAUT:	PUSHJ P,COMSXI		;Read sixbit author name
	JRST CNGCAL

CNGDAT:	PUSHJ P,COMDTI		;Read a date
	JRST CNGCAL
]	;END IFN ITS

IFN TNX,[
CNGACT:	AR%NAR ? .FBBBT,,CNGBIT	;DONT-REAP
	-1 ? .FBBK0,,CNGBIT	;NOT-BACKED-UP
	SFUST ? CNGSTR		;AUTHOR
	-1 ? .FBWRT,,CNGDAT	;CREATION-DATE
	-1 ? .FBREF,,CNGDAT	;REFERENCE-DATE
	FB%BSZ ? .FBBYV,,CNGDEC	;BYTE-SIZE
	-1 ? .FBSIZ,,CNGDEC	;LENGTH-IN-BYTES
IFN 20X,[77,,-1] .ELSE [0,,-1] ? .FBPRT,,CNGOCT	;PROTECTION
	FB%RET ? .FBBYV,,CNGDEC	;GENERATION-RETENTION-COUNT
	SACTF ? CNGSTR		;ACCOUNT
	FB%TMP ? .FBCTL,,CNGBIT	;TEMPORARY
	FB%DEL ? .FBCTL,,CNGBIT	;DELETED
	FB%UND ? .FBCTL,,CNGBIT	;DONT-DELETE

CNGBIT:	PUSHJ P,COMRD5
	CAMN A,[ASCII \NIL\]
	 TDZA A,A
	 SETO A,
CNGFDB:	HRRZ 1,DATJFN(IDX)
	HLL 1,CNGACT(C)
	MOVE 2,CNGACT-1(C)	;Mask
	MOVE 3,A		;New value
	CHFDB
	 ERJMP JSYSER
	POPJ P,

CNGDAT:	PUSHJ P,COMDTI
	JRST CNGFDB

CNGDEC:	PUSHJ P,COMDCI
	JRST CNGRFD

CNGOCT:	MOVEI T,8
	PUSHJ P,COMNUI
;;Here if right justified
CNGRFD:	MOVE T,CNGACT-1(C)	;Mask
	JFFO T,.+1
	SETCM T,CNGACT-1(C)
	LSH T,(TT)
	MOVNS TT
	LSH T,(TT)
	JFFO T,.+2
	 JRST CNGFDB		;No shifting necessary
	MOVEI T,36.
	SUBI T,(TT)
	LSH A,(T)
	JRST CNGFDB

CNGSTR:	MOVE 2,BP
	PUSHJ P,COMEUS		;Find end
	 SKIPA
	 JRST .-2		;Terminated by space, so keep searching
	SETZ 1,
	DPB 1,BP		;Insure terminating NULL
	HRRZ 1,DATJFN(IDX)
	XCT CNGACT-1(C)
	 ERJMP JSYSER
	POPJ P,
]	;END IFN TNX

IFN TNX,[
;;; Expunge directory command
COMEXP:	SKIPN USERID
	 CERR NLI,[NOT LOGGED IN]
	SETZ D,			;Clear options here
EXPOPT:	TRNE F,F.NWL		;End of options?
	 JRST EXPFNM
	PUSHJ P,COMRD5		;Get token
	 JUMPL BC,COMBAD
EXPOLP:	MOVEI T,EXPLEN-1
EXPOL1:	CAME A,EXPTAB(T)
	 SOJGE T,EXPOL1
	JUMPL T,[CERR UXO,[UNKNOWN EXPUNGE OPTION]]
	XCT EXPACT(T)
	 JRST COMBAD
	JRST EXPOPT

EXPTAB:	ASCII \TEMPO\		;TEMPORARY
EXPLEN==.-EXPTAB

EXPACT:	SKIPA

EXPFNM:	TLO D,ST.PON		;Do parse only
	PUSHJ P,COMGJF		;Get JFN for default
	 JRST JSYSER
	MOVEM 1,DATJFN(IDX)
	HRROI 1,RESBLK
	MOVE 2,DATJFN(IDX)
IFN 10X,MOVSI 3,(JS%DIR)
.ELSE	MOVE 3,[JS%DEV+JS%DIR+JS%PAF]
	JFNS
	MOVSI 1,(RC%EMO)
	HRROI 2,RESBLK
	RCDIR
	MOVE 1,DATJFN(IDX)
	RLJFN
	 JFCL
	SETZM 1,DATJFN(IDX)
	TLNN 1,(RC%NOM)
	 JRST JSYSER
IFN 20X,PUSH P,3
	MOVE 1,3
	GTDAL
IFN 20X,POP P,3
	PUSH P,2		;Save current allocation
IFN 10X,HRRZ 1,3		;Directory number
.ELSE [
	SETZ 1,
	MOVE 2,3
]
	DELDF
IFN 20X, ERJMP JSYSER
	MOVE 1,3
	GTDAL
	EXCH 2,(P)
	SUBM 2,(P)		;Save difference in allocation
	MOVEI A,[ASCIZ \EXPUNGE \]
	PUSHJ P,COMCTL
	POP P,A
	PUSHJ P,COMDCO
	PUSHJ P,COMSND
	JRST CTLLOP
];END IFN TNX (EXPUNGE COMMAND)

;;; Core buffer allocator
BUFALO:	MOVEI T,BUFBAS(IDX)     ;Index
	SETZM DATBPT(IDX)       ;Pointer is zero, meaning virgin buffer
	SETZM DATBCT(IDX)	;No room left in buffer
	SETZM DATLWD(IDX)	;No last word
IFN ITS,PUSHJ P,PAGALO
	LSH T,10.               ;Make into address
IFN TNX,[
	SETMM (T)		;Access page to create it
]	;END IFN TNX
	MOVEM T,DATBUF(IDX)	;Remember base of buffer
	POPJ P,

IFN ITS,[
PAGALO:	.CALL [ SETZ
		SIXBIT /CORBLK/
		%CLIMM,,%CBNDW+%CBNDR ;Write and read access
		%CLIMM,,%JSELF	;Into own job
		%CLIN,,T	;c(T) is page number
		%CLIMM+%CLEND,,%JSNEW] ;Fresh page
	 CERR NER,[NOT ENOUGH RESOURCES]
	POPJ P,
]	;END IFN ITS

;;; Core buffer deallocator
BUFDAL:	MOVEI T,BUFBAS(IDX)
	SETZM DATBPT(IDX)
	SETZM DATBCT(IDX)
	SETZM DATLWD(IDX)	;No last word
	SETZM DATBUF(IDX)
IFN ITS,PUSHJ P,PAGDAL
IFN TNX,[
	MOVNI 1,1		;-1 means unmapping a page
	MOVE 2,T		;Page number in right half
	HRLI 2,.FHSLF		;Process handle in left half
	SETZ 3,			;No repeat count
	PMAP
	 ERCAL CTLERR
]	;END IFN TNX
	POPJ P,

IFN ITS,[
PAGDAL:	.CALL [ SETZ
		SIXBIT /CORBLK/
		%CLIMM,,0	;Delete page
		%CLIMM,,%JSELF
		%CLIN+%CLEND,,T]
	 .LOSE %LSSYS
	POPJ P,
]	;END IFN ITS

;;; IOC error and asynchronous mark transmitters
;;; Both of these routines get called with all interrupts deffered and therefore can use a
;;;  shared packet
;;; A contains DATSTA(IDX)
;;; This must be called so that a POPJ returns to "top level".

;;; c(D)+1 contains error code,,pointer to asciz string
;;; c(D)+2 has return address
ASYERR:	PUSH P,PKTLOC		;Direct data to the async packet
	MOVEI T,ASYPKT
	MOVEM T,PKTLOC
	HRRI A,ST%ASY		;Channel now in ASYNC-MARKED state
	TLO A,ST.UNC		;But uncontinuable
	MOVEM A,DATSTA(IDX)
	TRO F,F.FHN		;Force outputting of a file handle
	MOVEI A,[ASCIZ \ERROR \]
	PUSHJ P,COMCTL		;This will output a transaction ID, which will be ignored
	HLLZ A,1(D)		;Get error code
	PUSHJ P,COMSXO
	MOVEI BYTE,40
	PUSHJ P,COMCHO
	HRRZ A,1(D)		;Now output the error string
	PUSHJ P,COMSTO
	MOVEI T,CO%ASY
	DPB T,[$CPKOP+ASYPKT]
	DPB BC,[$CPKNB+ASYPKT]
IFN ITS,[
	MOVEI T,CTRLO		;Perhaps have to send this over the control connection
	TRNN IDX,1		;Except if we are already sending data, use IDX's channel
	 MOVE T,CHACHN(IDX)
	.CALL [	SETZ
		SIXBIT /PKTIOT/
		%CLIN,,T
		%CLIMM+%CLEND,,ASYPKT]
	 .LOSE %LSSYS
	TRNN IDX,1		;if more packets might come in, defer interrupts
	 JRST ASYRET
	MOVE T,CHABIT(IDX)	;Defer interrupts on this channel until continued
	IORM T,SSYDF2		;Update saved copy of DF2
	.SUSET [.SIDF2,,T]
]	;END IFN ITS
IFN TNX,[
	MOVE 1,CTLJFN
	TRNN IDX,1
	 MOVE 1,CHAJFN(IDX)
	MOVEI 2,.MOPKS
	MOVEI 3,ASYPKT
	MTOPR
	 ERCAL CTLERR
	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	DIC
]	;END IFN TNX
ASYRET:	POP P,PKTLOC
	MOVE A,DATSTA(IDX)	;Insure A stays set up correctly
	JRST @2(D)

;;; c(D)+1 contains continuation address
ICCERR:	PUSH P,PKTLOC		;Direct data to the async packet
	MOVEI T,ASYPKT
	MOVEM T,PKTLOC
	HRRI A,ST%ASY		;Channel now in ASYNC-MARKED state
	TLZ A,ST.UNC		;They are continuable
	MOVEM A,DATSTA(IDX)
	TRO F,F.FHN		;Force outputting of a file handle
	MOVEI A,[ASCIZ \ERROR IOC R \] ;IOC error
	PUSHJ P,COMCTL          ;Start off error packet, open failed error code
IFN ITS,[
	.CALL [ SETZ            ;Now open ERR device to get error message
		SIXBIT /OPEN/
		%CLBIT,,.UAI
		%CLIMM,,ERRCH
		%CLIN,,[SIXBIT /ERR/]
		%CLIMM,,2       ;Use .IOS as error code word
		%CLIN+%CLEND,,DATCHN(IDX)]
	 .LOSE %LSSYS
	MOVEI T,ERRLEN-1        ;Read a reasonable number of character
	MOVE TT,[440700,,ERRBUF]
	.CALL [ SETZ
		SIXBIT /SIOT/
		%CLIMM,,ERRCH
		%CLIN,,TT
		%CLIN+%CLEND,,T]
	 .LOSE %LSSYS
	.CALL [ SETZ
		SIXBIT /CLOSE/
		%CLIMM+%CLEND,,ERRCH]
	 .LOSE %LSSYS
	SETZ BYTE,
	IDPB BYTE,TT            ;Insure trailing null
	MOVEI A,ERRBUF          ;Output error string to packet
	PUSHJ P,COMSTO
	SUBI BC,2		;The last two bytes don't want to go
]	;END IFN ITS

IFN TNX,[
	HRROI 1,ERRBUF		;Output to canonical place, error in AC2
	HRLOI 2,.FHSLF		;-1 in RH means last error
	MOVEI 3,ERRLEN-1	;Maximum number of bytes we can handle
	ERSTR
	 JFCL			;Undefined error number??
	  JFCL			;Won't fit -- too bad
IFN 10X,[
	SETZ 3,
	IDPB 3,1
]
	MOVEI A,ERRBUF
	PUSHJ P,COMSTO
]	;END IFN TNX

	PUSHJ P,ICCERP		;Send packet
	POP P,PKTLOC
	HRRZ T,1(D)		;Get continuation address
	MOVEM T,DATICN(IDX)	;Remember in case user end asks us to go on
	SUB P,[1,,1]		;Flush the old return address
	POPJ P,			;And return to "superior" of routine that had error

;;; Send IOC error packet
ICCERP:	MOVEI T,CO%ASY
	DPB T,[$CPKOP+ASYPKT]
	DPB BC,[$CPKNB+ASYPKT]

IFN ITS,[
	MOVEI T,CTRLO		;Perhaps have to send this over the control connection
	TRNN IDX,1		;Except if we are already sending data, use IDX's channel
	 MOVE T,CHACHN(IDX)
	.CALL [	SETZ
		SIXBIT /PKTIOT/
		%CLIN,,T
		%CLIMM+%CLEND,,ASYPKT]
	 .LOSE %LSSYS
	TRNN IDX,1		;If more packets might come in, defer interrupts
	 JRST ICCRET
	MOVE T,CHABIT(IDX)	;Defer interrupts on this channel until continued
	IORM T,SSYDF2		;Update saved copy of DF2
				; Runs at interrupt level -- the interrupt top-level
				; will setup the saved defer word before dismissing.
]	;END IFN ITS

IFN TNX,[
	MOVE 1,CTLJFN
	TRNN IDX,1
	 MOVE 1,CHAJFN(IDX)
	MOVEI 2,.MOPKS
	MOVEI 3,ASYPKT
	MTOPR
	 ERCAL CTLERR
	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	DIC
]	;END IFN TNX

ICCRET:	MOVE A,DATSTA(IDX)	;Insure A stays set up correctly
	POPJ P,

;;; Recieved a new packet.  Write it to the appropriate file.  IDX set up, but packet
;;; not read from system.  Since we can only get one interrupt at a time, we can use a
;;; common packet buffer for the data until/unless we get an IOC error in which case
;;; the data must be saved in the allocated buffer.
WRIONE:
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /PKTIOT/
		%CLIN,,CHACHN(IDX)
		%CLIMM+%CLEND,,WRIPKT]
	 .LOSE %LSSYS           ;HMM...THIS BETTER NOT HAPPEN
]	;END IFN ITS
IFN TNX,[
	MOVE 1,CHAJFN(IDX)
	MOVEI 2,.MOPKR
	MOVEI 3,WRIPKT
	MTOPR
	 ERCAL CTLERR
]	;END IFN TNX
	SKIPL A,DATSTA(IDX)     ;CHANNEL ACTIVE?
	 JRST CPOPJ1		;HMMM...CHANNEL NOT ACTIVE, IGNORE THE PACKET
	LDB T,[WRIPKT+$CPKOP]   ;GET THE OPCODE
	CAIN T,CO%SYN           ;Synchronous mark, process it (ignoring channel state)
	 JRST WRIOSY
	JRST @WRIDSP(A)		;ACTIONS TO FOLLOW DEPEND UPON CHANNEL STATE

;Dispatch table
WRIDSP:	WRICLO                  ;CHANNEL CLOSED
	WRIOPN                  ;CHANNEL OPEN, NORMAL PROCESSING
	WRIASY                  ;ASYNCHRONOUS MARKED
	WRISYN                  ;SYNCHRONOUS MARKED STATE
	WRIEOF                  ;EOF STATE

;Channel closed, at eof, or sync or asynch mark.  Interrupts shouldn't happen
; Channel cannot stay in synchronous mark state for any amount of time, so this shouldn't
; happen either
WRICLO:
WRIASY:
WRISYN:
WRIEOF:	TLNN A,ST.SYN		;Expecting sync mark?
CPOPJ1:	 AOS (P)		;Nope, don't take any more interrupts
	POPJ P,                 ;Return and perform appropriate action

;Channel in open state, only one allowed to receive a new packet
WRIOPN:	CAIN T,CO%BDT           ;BINARY DATA
	 JRST WRIBIN
	CAIN T,CO%TXT           ;TEXT DATA
	 JRST WRITXT
	CAIN T,CO%EOF           ;END OF FILE?
	 JRST WRIOEO
	AERR WRIASY,IPO,[ILLEGAL PACKET OPCODE]

;Synchronous mark received
WRIOSY:	TLZE A,ST.SYN           ;WAS ONE EXPECTED
	 JRST WRISY0            ;YES, THROW IT AWAY AND PREPARE FOR MORE DATA
	HRRI A,ST%SYN           ;ELSE PUT CHANNEL INTO SYNC MARKED STATE
	MOVEM A,DATSTA(IDX)
IFN ITS,[
	MOVE T,CHABIT(IDX)	;Defer interrupts on this channel until mark processed
	IORM T,SSYDF2		;Update saved DF2
	.SUSET [.SIDF2,,T]
]	;END IFN ITS
IFN TNX,[
	MOVEI 1,.FHSLF
	MOVE 2,CHABIT(IDX)
	DIC
]	;END IFN TNX
	AOS (P)
	POPJ P,                 ;RETURN AND DISMISS INTERRUPT

WRISY0:	TLZ A,ST.SYN		;Make sure sync mark is no longer expected
	PUSHJ P,@DATSYA(IDX)    ;Call routine to handle receipt of sync mark
	MOVEM A,DATSTA(IDX)     ;Routine may have altered status
	POPJ P,

;EOF received
WRIOEO:	PUSHJ P,WRIFOR          ;FORCE OUT ANY REMAINING BUFFERS
	HRRI A,ST%EOF           ;PUT CHANNEL IN EOF STATE
	MOVEM A,DATSTA(IDX)
	POPJ P,                 ;RETURN AND DISMISS INTERRUPT

;Text data received
;Note: ITS SIOT is much faster if you always send a multiple of 5 characters
;so that everything stays on word boundaries.  So we will move any residual
;part word down to the front of the buffer and save it for next time, setting
;DATBCT to the number of characters saved and DATBPT to point after them.
WRITXT:	TLNE A,ST.BIN           ;FILE OPEN IN BINARY MODE?
WRIIDO:	 AERR WRIASY,IDO,[ILLEGAL DATA OPCODE]
	SETZ BC,
	MOVE BP,DATBUF(IDX)     ;USE BUFFER TO HOLD BYTES
	HRLI BP,440700          ;7 BIT BYTES
	SKIPE DATBPT(IDX)
	 MOVE BP,DATBPT(IDX)	;POINT AFTER OLD STUFF IN BUFFER
	LDB T,[WRIPKT+$CPKNB]   ;NUMBER OF BYTES
	MOVE TT,[441000,,WRIPKT+%CPKDT]
;;; Note: Assumption is that even if the packet consisted of all newlines the buffer could
;;;	  not be overflowed.  If this is not the case, then something else has to be hacked
;;;	  here.
WRITX1:	SOJL T,WRITX0           ;DONE WHEN NO MORE BYTES
	ILDB BYTE,TT            ;ELSE GET NEXT BYTE
	TLNN A,ST.RAW		;If raw mode, don't translate
	 XCT CHR210(BYTE)	;Convert to PDP-10 code
	  SKIPA			;Non-skip means character not processed
	   JRST WRITX1		;Skip means character has been processed
	IDPB BYTE,BP
	AOJA BC,WRITX1

WRITX0:	JUMPE BC,CPOPJ          ;If no bytes to write out (0 length packet), return and dismis
	ADDM BC,DATLEN(IDX)	;Keep track of number of bytes written
	MOVE BP,DATBUF(IDX)	;Write starting from beginning of buffer
	HRLI BP,440700
	ADD BC,DATBCT(IDX)	;Include characters left over from last time
	MOVE T,BC		;Round down to multiple of a word
	IDIVI T,5
	IMULI T,5
	SUB BC,T		;Number of characters that will be left over
	MOVEM BC,DATIOC(IDX)
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /SIOT/
		%CLIN,,DATCHN(IDX)
		%CLIN,,BP
		%CLIN+%CLEND,,T]
	 JFCL                   ;Here if IOC error
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	MOVE 2,BP
	MOVN 3,T
	JUMPE 3,.+3
	SOUT
	 ERJMP .+1
	MOVN T,3
	MOVE BP,2
]	;END IFN TNX
	MOVEM T,DATBCT(IDX)	;Save the byte count remaining within the word-aligned part
	MOVEM BP,DATBPT(IDX)    ;and the byte pointer to not-yet-output chars
	JUMPE T,WRITX2		;If everything SIOT'ed, go handle residue
	IOCERR WRITX2		;Else IOC error, continuation when fixed up after SIOT done

WRITX2:	SKIPN BC,DATIOC(IDX)	;Get number characters to be saved for next time
	 JRST [ SETZM DATBPT(IDX) ? POPJ P, ]	;No characters
	CAIL BC,5
	 PUSHJ P,CTLERR		;This can't happen
	MOVEM BC,DATBCT(IDX)
	MOVE T,DATBPT(IDX)
	;; Don't need to make BP agree with ITS on TOPS-20, since this IBP equalizes them
	IBP T			;Points to first byte to be saved for next time
	MOVE TT,(T)		;Move that word down to the front
	MOVE BP,DATBUF(IDX)	;Make a byte pointer to after them
	HRLI BP,440700
	IBP BP
	SOJG BC,.-1
	MOVEM BP,DATBPT(IDX)
	MOVEM TT,(BP)
	POPJ P,

;Binary data received
WRIBIN:	TLNN A,ST.BIN           ;MUST BE A BINARY MODE FILE
	 JRST WRIIDO
	SKIPE T,DATBPT(IDX)     ;ARE WE IN THE MIDDLE OF A PREVIOUS OPERATION?
	 JRST WRIBI0            ;YES, SO CONTINUE PROCESSING IT
	HRRZ T,DATBYT(IDX)
	CAIE T,16.              ;16 BIT BYTE MODE?
	 JRST WRIBI1            ;NOPE, SO NEED SPECIAL HANDLING ANYWAY
	LDB T,[WRIPKT+$CPKNB]   ;NUMBER OF BYTES
	MOVEI D,(T)             ;COPY INTO D
	LSH T,-1		;Number of bytes getting written
	ADDM T,DATLEN(IDX)
	LSH T,-1                ;NUMBER OF PDP-10 WORDS, ROUNDED DOWN
	MOVE TT,[444400,,WRIPKT+%CPKDT]
IFN ITS,[
	.CALL [ SETZ            ;WRITE THE DATA DIRECTLY FROM THE PACKET
		SIXBIT /SIOT/
		%CLIN,,DATCHN(IDX)
		%CLIN,,TT       ;POINTER
		%CLIN+%CLEND,,T]
	SKIPA                   ;IOC error
	 JUMPE T,WRIBI2         ;WROTE OUT ALL THE DATA, PROCEED
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	MOVE 2,TT		;Pointer
	MOVN 3,T		;Negative count -- output this many bytes
	JUMPE 3,.+3
	SOUT
	 ERJMP .+2
	  JRST [PUSHJ P,ITSBP
		MOVE TT,2	;Get updated pointer
		JRST WRIBI2]
	MOVN T,3
	MOVE TT,2
]	;END IFN TNX
	MOVE B,DATBUF(IDX)      ;SAVE PACKET IN IDX BUFFER
	MOVEI C,(B)             ;COPY FOR TERMINATION CONDITION
	HRLI B,WRIPKT
	BLT B,%CPMXW-1(C)       ;SAVE ALL OF PACKET
	SUBI C,WRIPKT           ;OFFSET FOR BYTE POINTER
	ADD TT,C
	MOVEM TT,DATBPT(IDX)    ;SAVE POINTER
	MOVEM T,DATBCT(IDX)     ;AND SAVE COUNT
	IOCERR WRIBI5           ;GIVE THE IOC ERROR, CONTINUATION

WRIBI5:	MOVE TT,DATBPT(IDX)     ;IOC ERROR RECOVERY PUTS FINAL BP HERE
	SETZM DATBPT(IDX)       ;No longer need pointer
	MOVE D,DATBUF(IDX)      ;SAVED PACKET, AND NEED TO GET BYTE COUNT BACK
	LDB D,[$CPKNB (D)]

WRIBI2:	TRNN D,3                ;DID WE GET AN ODD NUMBER OF BYTES?
	 POPJ P,                ;NOPE, THEN DONE WITH PACKET
;Here if 16 bit byte mode, but have an odd number of bytes.  Next packet will have to do
; it slowly
	LSH D,-2                ;NUMBER OF WORDS - 1
	IBP TT			;POINT AT NEXT BYTE TO BE DONE
	MOVE T,(TT)		;GET THE BYTE
	MOVE TT,DATBUF(IDX)     ;ADDRESS IN WHICH TO SAVE
	MOVEM T,(TT)            ;SAVE THE WORD CONTAINING THE BYTE IN THE BUFFER
	HRLI TT,242000          ;A POINTER TO IT
	MOVEM TT,DATBPT(IDX)
	MOVEI T,1               ;ONE BYTE REMAINS
	MOVEM T,DATBCT(IDX)
	POPJ P,                 ;THEN WE ARE DONE

;Here if non-16bit byte mode but no bytes left over from last time, byte size in T
WRIBI1:	SETZM DATBCT(IDX)       ;Make sure byte count is 0
	HRLI T,440000           ;Prototype byte pointer
	DPB T,[300600,,T]       ;Deposit correct byte size into pointer
	HRR T,DATBUF(IDX)       ;Pointer to buffer
;;; Fall into WRIBI0

;Here if had some bytes left over from last time, T has the pointer to last byte written
WRIBI0:	LDB BC,[WRIPKT+$CPKNB]  ;COUNT OF BYTES IN PACKET
	LSH BC,-1		;16 bit mode only has half as many
	ADDM BC,DATLEN(IDX)	;Keep track of number of more bytes to write
	MOVEI C,(BC)            ;Save number of bytes
	ADD C,DATBCT(IDX)       ;Add in number of bytes left over
	HRRZ TT,DATBUF(IDX)     ;Pointer for SIOT (used later)
	HRLI TT,444400
	JUMPE BC,WRIBI6         ;If no bytes in packet, finish up here and now
	HRRI B,(T)              ;THIS IS THE FIRST WORD TO SIOT OUT OF
	MOVE BP,[442000,,WRIPKT+%CPKDT]
WRIBI4:	SOJL BC,WRIBI3          ;LOOP OVER ALL BYTES
	ILDB BYTE,BP
	IDPB BYTE,T
	JRST WRIBI4

WRIBI3:	HRRZ D,DATBPW(IDX)
	CAIGE C,(D)		;Enough bytes to make up a word?
	 JRST WRIBI6            ;Nope
	MOVE D,T		;Must increment byte pointer in case last byte was written
	IBP D
	SUBI D,(B)
	HRRZI B,(D)		;Get rid of byte pointer part
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /SIOT/
		%CLIN,,DATCHN(IDX)
		%CLIN,,TT
		%CLIN+%CLEND,,B]
	SKIPA                   ;IOC error
	 JUMPE B,WRIBI6         ;Done writing successfully, so go on
	MOVEM TT,DATBPT(IDX)
	MOVEM B,DATBCT(IDX)
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	MOVE 2,TT
	MOVN 3,B
	JUMPE 3,.+3
	SOUT
	 ERJMP .+2
	  JRST [PUSHJ P,ITSBP
		MOVE TT,2	;Rest of code needs updated pointer
		JRST WRIBI6]
	MOVEM 2,DATBPT(IDX)
	MOVNM 3,DATBCT(IDX)
]	;END IFN TNX
	HLL C,T			;Save final byte pointer
	MOVEM C,DATIOC(IDX)     ;Remember total number of bytes in buffer for continuation
	IOCERR WRIBI7           ;IOC ERROR, CONTINUATION TO WRIBI7

WRIBI7:	MOVE TT,DATBPT(IDX)     ;Restore byte pointer, IOC error handler leaves final ptr here
	HRRZ C,DATIOC(IDX)      ;Restore total number of bytes that were in buffer
	HLLZ T,DATIOC(IDX)	;Also restore left half of final byte pointer

;Here after IOC error fixed or after normal completion of output operation
WRIBI6:	SETZM DATBPT(IDX)       ;Assume no bytes left
	IDIV C,DATBPW(IDX)	;Remainder is number of bytes left over in last word
	JUMPE D,CPOPJ           ;We assumed correctly, no extra words
	HRR T,DATBUF(IDX)	;Pointer to buffer
	IBP TT			;Point at next byte to go out
	MOVE C,(TT)		;Get the last word which has extra bytes in it
	MOVEM C,(T)             ;Store as first word in buffer
	MOVEM T,DATBPT(IDX)	;New byte pointer
	MOVEM D,DATBCT(IDX)     ;And character count
	POPJ P,

;;; Force out any data remaining in the buffer.  Called from main program level.
;;; This is -NOT- for continuing from IOC errors, which is done by a different routine.
;;; It is for writing out a residual half-word in binary mode, or for
;;; writing out residual part-word characters in text mode.
WRIFOR:	SKIPN T,DATBPT(IDX)	;Any bytes in buffer?
	 POPJ P,                ;Nope, then done right now
	MOVE TT,DATSTA(IDX)	;Binary mode?
	TLNN TT,ST.BIN
	 JRST [	MOVE TT,DATBUF(IDX)	;Pointer to beginning of buffer
		HRLI TT,440700
		MOVE T,DATBCT(IDX)	;Number of bytes now in buffer
		JRST WRIFR1 ]
	HRRZS T			;Get rid of byte position and size info
	MOVE TT,DATBUF(IDX)     ;To build byte pointer
	HRLI TT,444400
	SUBI T,1(TT)            ;First calculate actual number of words to SIOT
	MOVMS T
WRIFR1:
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /SIOT/
		%CLIN,,DATCHN(IDX)
		%CLIN,,TT
		%CLIN+%CLEND,,T]
	 JFCL                   ;IOC errors will get handled in the wash
	MOVEM T,DATBCT(IDX)     ;This will be 0 if no IOC error
	MOVEM TT,DATBPT(IDX)
	JUMPN T,CPOPJ           ;If got IOC error, return now
	SETZM DATBPT(IDX)       ;Else leave pointer zeroed out
	POPJ P,
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	MOVE 2,TT
	MOVN 3,T
	JUMPE 3,.+3
	SOUT
	 ERJMP .+2
	  JRST [SETZM DATBPT(IDX)
		POPJ P,]
	MOVEM TT,DATBPT(IDX)
	MOVNM T,DATBCT(IDX)
	POPJ P,
]	;END IFN TNX

;;; Here to send one packet over a data conneciton.  IDX is set up.  Called with interrupts
;;; off so that the shared packet buffer may be used
REAONE:	MOVE A,DATSTA(IDX)	;Get channel state
	TLZE A,ST.SYN           ;Is a synchronous mark required on this channel?
	 JRST REASSY            ;Yes, send it (ignoring channel state)
	JRST @READSP(A)		;Actions to follow depend upon channel state

;Dispatch table
READSP:	REACLO                  ;Channel closed
	REAOPN                  ;Channel open, normal processing
	REAASY                  ;Asynchronous marked (should never happen)
	REASYN                  ;Synchronous marked state
	REAEOF                  ;EOF state

;Channel closed, at eof, or sync or asynch mark.  Interrupts shouldn't happen
; Channel cannot stay in synchronous mark state for any amount of time, so this shouldn't
; happen either
REACLO:
REAASY:
REASYN:
REAEOF:	AOS (P)
	POPJ P,

;Here to send sync mark
REASSY:	MOVEI T,CO%SYN          ;Synchronous mark opcode
	HRRI A,ST%SYN           ;Now in sync mark state
	PUSHJ P,REAEPK          ;Output the packet, but return here
	 JFCL
	PUSHJ P,@DATSYA(IDX)    ;Call the routine to process the synchronous mark
	MOVEM A,DATSTA(IDX)
	POPJ P,

;Here to send an empty packet, opcode is in T
REAEPK:	DPB T,[$CPKOP+REAPKT]   ;Deposit in packet
	SETZ T,
	DPB T,[$CPKNB+REAPKT]   ;Packet contains no information other than opcode
IFN ITS,[
	.CALL [ SETZ
		SIXBIT/PKTIOT/
		%CLIN,,CHACHN(IDX)
		%CLIMM+%CLEND,,REAPKT]
	 .LOSE %LSSYS
]	;END IFN ITS
IFN TNX,[
	MOVE 1,CHAJFN(IDX)
	MOVEI 2,.MOPKS
	MOVEI 3,REAPKT
	MTOPR
	 ERCAL CTLERR
]	;END IFN TNX
	MOVEM A,DATSTA(IDX)     ;Remember to save new status word
	AOS (P)			;Skip return
	POPJ P,

;Here when hit EOF.  Put channel into EOF state and send EOF packet
REAOEO:	HRRI A,ST%EOF           ;EOF state
	MOVEI T,%COEOF          ;Send eof packet
IFN ITS,[
	JRST REAEPK
]	;END IFN ITS
IFN TNX,[
	MOVE 1,CHAJFN(IDX)
	MOVEI 2,.MOEOF
	MTOPR
	 ERCAL CTLERR
	MOVEM A,DATSTA(IDX)
	AOS (P)
	POPJ P,
]	;END IFN TNX

;Here to send more data over the data connection
REAOPN:	TLNE A,ST.BIN           ;Binary mode?
	 JRST REABIN            ;Yes, requires different code
	SKIPG DATBCT(IDX)       ;Any bytes left in buffer?
	 PUSHJ P,REABUF         ;Nope, fill up buffer
	SKIPG T,DATBCT(IDX)     ;Did we get any bytes?
	 JRST REAOEO            ;Nope, put channel into EOF state and send an EOF packet
	MOVE TT,DATBPT(IDX)     ;Pointer into buffer
	SETZ BC,                ;No bytes in packet
	MOVE BP,[441000,,REAPKT+%CPKDT] ;Pointer to start of data in packet
REATXT:	ILDB BYTE,TT            ;Get next byte from file
	TLNN A,ST.RAW		;Raw mode means don't translate
	 XCT CHR2LM(BYTE)	;Check if any special processing is needed
	  AOJA BC,REATX0	;None needed, just output character
	  JRST REATX1		;Special processing is done, so just punt the byte
	  JRST REATX4		;Skipped twice, a rubout escape.
	MOVEI BYTE,215		;Skipped three times, output a carriage return
	IDPB BYTE,BP
	ADDI BC,1
	SOJLE T,REATX5		;and absorb following linefeed if any
REATX6:	ILDB BYTE,TT
	CAIN BYTE,12
	 JRST REATX1
	ADD TT,[070000,,]	;Not a line feed, put it back
	AOJA T,REATX1		;Treat stray CR as CRLF

REATX5:	PUSHJ P,REABUF		;Get next buffer, first char follows a CR
	SKIPG T,DATBCT(IDX)
	 JRST REATXS		;End of file
	MOVE TT,DATBPT(IDX)
	JRST REATX6

REATX4:	TLNE A,ST.SUI		;Super-image mode means just send rubouts
	 AOJA BC,[MOVEI BYTE,177 ? JRST REATX0]
	SOJLE T,REATX2		;Jump if end of file-buffer
REATX3:	ILDB BYTE,TT		;Get the byte that follows the rubout
	XCT CHRQLM(BYTE)	;Convert.  Will need no special processing
	ADDI BC,1
REATX0: IDPB BYTE,BP		;Store the byte
REATX1:	CAML BC,CHPMXC          ;Have we written the maximum number of bytes?
	 SOJA T,REATXS		;Yes, send the packet and return (account for byte as well)
	SOJG T,REATXT		;If more characters in buffer just go on
	PUSHJ P,REABUF          ;Read a new bufferful
	SKIPG T,DATBCT(IDX)     ;Did we get any more data?
	 JRST REATXS            ;Nope, just send what we have so far
	MOVE TT,DATBPT(IDX)     ;Else get the byte pointer
	JRST REATXT             ;And proceed with the transmission

REATX2:	PUSHJ P,REABUF		;Get next buffer, first char is quoted with rubout
	SKIPG T,DATBCT(IDX)
	 JRST REATXS		;Oops, end of file in bad place, ignore the stray rubout
	MOVE TT,DATBPT(IDX)
	JRST REATX3

;Here to store T and TT and send the packet
REATXS:	MOVEM T,DATBCT(IDX)     ;Save byte count
	MOVEM TT,DATBPT(IDX)    ;And pointer
	JUMPE BC,CPOPJ		;Don't bother transmitting if the packet is null
	MOVEI T,CO%TXT          ;Data opcode
	TLNE A,ST.BIN           ;Except if binary mode
	 TRO T,100              ;This is the correct opcode
	DPB T,[REAPKT+$CPKOP]
	DPB BC,[REAPKT+$CPKNB]
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /PKTIOT/
		%CLIN,,CHACHN(IDX)
		%CLIMM+%CLEND,,REAPKT]
	 .LOSE %LSSYS
]	;END IFN ITS
IFN TNX,[
	MOVE 1,CHAJFN(IDX)
	MOVEI 2,.MOPKS
	MOVEI 3,REAPKT
	MTOPR
	 ERCAL CTLERR
]	;END IFN TNX
	POPJ P,                 ;Packet has been transmitted, so return

;Here to read in binary mode
REABIN:	HRRZ T,DATBYT(IDX)      ;Get byte size
	SKIPG DATBCT(IDX)	;If bytes in the buffer
	 CAIE T,16.		; or if not 16 bit bytes, use slow mode
	  JRST REABIS
	MOVE T,CHPMXW		;Maximum number of words in a packet
	MOVE TT,[444400,,REAPKT+%CPKDT]
IFN ITS,[
	.CALL [ SETZ            ;Read data into the packet
		SIXBIT /SIOT/
		%CLIN,,DATCHN(IDX)
		%CLIN,,TT
		%CLIN+%CLEND,,T]
	 JRST REABI0            ;Ioc error
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	MOVE 2,TT
	MOVN 3,T		;Negative count is number of bytes we want
	SIN
	 ERCAL REAIOC		;Skips if IOC error as opposed to EOF
	  SKIPA
	   JRST REABI0
	MOVN T,3
	MOVE TT,2
]	;END IFN TNX
	CAMN T,CHPMXW		;Did we get any data at all?
	 JRST REAOEO            ;Nope, EOF: send EOF packet, change channel state, and return
	MOVE BC,CHPMXW		;Calculate actual number of bytes read
	SUBI BC,(T)
	LSH BC,2
	SETZB T,TT		;Don't get faked into thinking stuff is buffered
	JRST REATXS             ;Send the packet

;Here on IOC error
REABI0:	MOVE B,DATBUF(IDX)      ;SAVE PACKET IN IDX BUFFER
	MOVEI C,(B)             ;COPY FOR TERMINATION CONDITION
	HRLI B,REAPKT
	BLT B,%CPMXW-1(C)       ;SAVE ALL OF PACKET
	SUBI C,WRIPKT           ;OFFSET FOR BYTE POINTER
	ADD TT,C
	MOVEM TT,DATBPT(IDX)    ;SAVE POINTER
	MOVEM T,DATBCT(IDX)     ;AND SAVE COUNT
	IOCERR REABI1           ;GIVE THE IOC ERROR, CONTINUATION

;IOC error continuation
REABI1:	MOVE BC,CHPMXW		;Calculate actual number of bytes read
	SUB BC,DATBCT(IDX)
	LSH BC,1
	MOVEI T,CO%BDT          ;Data opcode
	DPB T,[REAPKT+$CPKOP]
	DPB BC,[REAPKT+$CPKNB]
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /PKTIOT/
		%CLIN,,CHACHN(IDX)
		%CLIMM+%CLEND,,DATBUF(IDX)]
	 .LOSE %LSSYS
]	;END IFN ITS
IFN TNX,[
	MOVE 1,CHAJFN(IDX)
	MOVEI 2,.MOPKS
	MOVEI 3,DATBUF(IDX)
	MTOPR
	 ERCAL CTLERR
]	;END IFN TNX
	POPJ P,                 ;Packet has been transmitted, so return

;Slow binary mode.  Read block into buffer and use ILDB/IDPB loop to fill packet
REABIS:	SKIPG DATBCT(IDX)       ;Any bytes left in buffer?
	 PUSHJ P,REABUF         ;Nope, fill up buffer
	SKIPG T,DATBCT(IDX)     ;Did we get any bytes?
	 JRST REAOEO            ;Nope, put channel into EOF state and send an EOF packet
	MOVE TT,DATBPT(IDX)     ;Pointer into buffer
	SETZ BC,                ;No bytes in packet
	MOVE BP,[442000,,REAPKT+%CPKDT] ;Pointer to start of data in packet
REABS0:	ILDB BYTE,TT            ;Get next byte from file
	IDPB BYTE,BP            ;Store the byte
	ADDI BC,2		;Two more bytes
	CAML BC,CHPMXC		;Have we written the maximum number of bytes?
	 SOJA T,REATXS		;Yes, send the packet and return
	SOJG T,REABS0		;If more characters in buffer just go on
	HRRZ T,DATBYT(IDX)	;This 16 bit byte mode?
	CAIN T,16.
	 JRST REABS1		;Yup, send a small packet and do the rest quickly
	PUSHJ P,REABUF          ;Read a new bufferful
	SKIPG T,DATBCT(IDX)     ;Did we get any more data?
	 JRST REATXS            ;Nope, just send what we have so far
	MOVE TT,DATBPT(IDX)     ;Else get the byte pointer
	JRST REABS0             ;And proceed with the transmission

REABS1:	SETZB T,TT		;Make sure we go through fast path next time
	JRST REATXS


;;; Routine to fill up in-core buffer
;;; Destroy's: B, C, D, T, TT
REABUF:	MOVE T,DATBUF(IDX)      ;Pointer to the buffer
	HRLI T,440700           ;Assume 7 bit bytes
	TLNE A,ST.BIN           ;Binary mode?
	 HRLI T,444400          ;Yes, really 36 bit bytes
	MOVEM T,DATBPT(IDX)     ;Byte pointer if no IOC error
	MOVEI TT,2000*5         ;This is correct number of bytes for text mode
	TLNE A,ST.BIN           ;But is it binary mode?
	 MOVEI TT,2000          ;Yes, then this is correct byte count
	MOVEI B,(TT)            ;Count expected maximally
	TLNN A,ST.BIN		;Can't have saved word in binary mode
	 SKIPN D,DATLWD(IDX)	;Do we have a saved last word?
	  JRST REABF6		;Nope, proceed normally
	SETZM DATLWD(IDX)	;No more last word
	MOVEM D,(T)		;Save the word as first buffer word
	ADDI T,1		;Increment pointer
	SUBI TT,5		;Read 5 fewer bytes
REABF6:	TLNE A,ST.DIR		;Directory listing?
	 JRST REDRBF		;Yes, handled specially
IFN ITS,[
	.CALL [ SETZ
		SIXBIT /SIOT/
		%CLIN,,DATCHN(IDX)
		%CLIN,,T
		%CLIN+%CLEND,,TT]
	 JRST REABF1            ;IOC error
]	;END IFN ITS
IFN TNX,[
	MOVE 1,DATJFN(IDX)
	MOVE 2,T
	MOVN 3,TT		;Negative count is number of bytes we want
	SIN
	 ERCAL REAIOC		;Skips if IOC error as opposed to EOF, sets up T and TT
	  SKIPA
	   JRST REABF1
	MOVN TT,3
	MOVE T,2
]	;END IFN TNX
REABF3:	SUBI B,(TT)             ;Actual number of bytes read
	TLNN A,ST.BIN		;Binary mode?
	 JRST REABF4		;Nope, no special processing
	HRRZ D,DATBYT(IDX)
	DPB D,[300600,,DATBPT(IDX)] ;Correct size bytes
	MOVEI C,36.		;Have number of 36 bit words, need number of real bytes
	IDIVI C,(D)
	IMULI B,(C)		;Calculate actual number of bytes read
REABF4:	MOVEM B,DATBCT(IDX)     ;Remember count
IFN TNX,[
	POPJ P,			;No need to do trailing control-C checking here
]	;END IFN TNX
IFN ITS,[
	SKIPE B			;Return right away if we read nothing
	 TLNE A,ST.BIN		;If binary mode then done
	  POPJ P,
IFN ITS,[
;; TT has number of bytes we tried to read, T has pointer to last byte hacked (almost...)
;; Due to gross ITS lossage, check for initial special case of 440700,, and
;; fix it
	HLRZ TT,T
	CAIN TT,440700
	 SUB T,[430000,,1]
]	;END IFN ITS
	CAIE TT,(B)		;If we got less than we wanted, we hit EOF
	 JRST READLC
;; We got a full bufferload, but we may have hit EOF!  So, must save last word and tack
;; it on next time when we'll know for sure whether we got to EOF
	MOVE TT,(T)		;Get the last word
	TRO TT,1		;Force it to be non-zero by setting bit 35 (argghh!)
	MOVEM TT,DATLWD(IDX)	;Save the "Last word"
	SUBI B,5	
	MOVEM B,DATBCT(IDX)
	POPJ P,

;; Search backwards removing trailing eof chars from the last word
;; T has BP to last byte read, B has count of bytes
READLC:	LDB TT,T                ;Get last character
	CAIE TT,^C
	 CAIN TT,^L
	  SOJG B,[ ADD T,[070000,,]
		   JUMPGE T,READLC
		   SUB T,[430000,,1]
		   JRST READLC]
	JUMPE B,REABUF		;Get another bufferful if no valid bytes found
	MOVEM B,DATBCT(IDX)     ;Store number of bytes in buffer
	POPJ P,                 ;Then return
]	;END IFN ITS

REABF1:	POP P,DATIOC(IDX)       ;Save address of our caller
	HRLM B,DATIOC(IDX)      ;Also save total number of bytes to be read
	MOVEM T,DATBPT(IDX)     ;Pointer
	MOVEM TT,DATBCT(IDX)    ;Remaining bytes to read
	IOCERR REABF2

REABF2:	PUSH P,DATIOC(IDX)      ;Restore adr of our caller
	HLRZ B,DATIOC(IDX)      ;Total number of bytes expected
	MOVE TT,DATBCT(IDX)     ;Need bytes left to read
	JRST REABF3

IFN TNX,[
REAIOC:	MOVE T,2		;Updated byte pointer
	MOVN TT,3		;Updated count
	MOVEI 1,.FHSLF		;Get last error
	PUSHJ P,$GETER
	 JFCL
	HRRZS 2			;Only error number
	CAIE 2,IOX4		;EOF, so non-skip
	 AOS (P)
	MOVE 2,T		;Callers expect these results in 2 and 3
	MOVN 3,TT
	POPJ P,

$GETER:
IFN 10X,[
	PUSH P,4
	PUSH P,5
	PUSH P,6
	PUSH P,7
	PUSH P,10
]
	GETER
	 ERJMP .+2
IFN 10X,[
	 AOS -5(P)
	POP P,10
	POP P,7
	POP P,6
	POP P,5
	POP P,4
]
.ELSE	 AOS (P)
	POPJ P,

]	;END IFN TNX

;Interrupt table
IFN ITS,[
INTTAB:
	LOC 42
	-INTLEN,,INTTAB
LOC INTTAB
	17,,P
	%PIIOC ? 0 ? %PIIOC+%PIDBG+%PIDWN ? 177777 ? IOCINT
	%PIDBG ? 0 ? %PIDBG+%PIDWN ? 0 ? DBGINT
	%PIDWN ? 0 ? %PIDBG+%PIDWN ? 0 ? DWNINT
REPEAT MAXIDX,[
	0 ? 1_<.RPCNT+3> ? %PIDBG+%PIDWN ? 177777 ? CHAINT+<2*.RPCNT>
]

INTLEN==.-INTTAB

;;; Here on receipt of channel interrupt from one of the chaosnet channels.
;;; Figure out which one, and perform the appropriate actions.  All AC's saved by system.
;;; All other channel interrupts deffered
CHAINT:	MOVEI IDX,0             ;IDX will contain index that got interrupt
	JRST CHAIN0
	MOVEI IDX,1
	JRST CHAIN0
	MOVEI IDX,2
	JRST CHAIN0
	MOVEI IDX,3
	JRST CHAIN0
	MOVEI IDX,4
	JRST CHAIN0
	MOVEI IDX,5
;	JRST CHAIN0
CHAIN0:	PUSHJ P,CHALOP          ;Handle this IDX
	MOVE T,SSYDF2		;Cause correct DF2 when dismissed
	MOVEM T,-20(P)		;Correct offset: all AC's, the old PC
	.CALL [ SETZ
		SIXBIT /DISMIS/
		%CLBTW,,INTTAB
		%CLIN+%CLEND,,P]
	 .LOSE %LSSYS

;Here with IDX properly set up
CHALOP:	.CALL [ SETZ            ;Find out why the interrupt happened
		SIXBIT /WHYINT/
		%CLIN,,CHACHN(IDX)
		%CLOUT,,T       ;%WYCHA
		%CLOUT,,T       ;State
		%CLOUT+%CLEND,,TT] ;#in packets available ,, #out packets available
	 .LOSE %LSSYS           ;Hmm...
	JRST CHAIND(T)          ;Dispatch on state
]	;END IFN ITS

;Dispatch table for channel state
CHAIND:	JRST CHACLS             ;Closed, so close down the channel (protocol violation!!)
	JRST CHALSN             ;Listen!!
	JRST CHARFC             ;RFC received!!(!!)
	JRST CHARFS             ;RFC SENT!!!!!! (This is getting out of hand...)
	JRST CHAOPN             ;Open ("Better, better")
	JRST CHALOS             ;Hmm...LOS received
	JRST CHAINC             ;Incomplete [poor Lisp Machine died....]


CHARFS:	POPJ P,
CHALSN:
CHARFC:

CHALOS:
CHAINC:			
CHACLS:
;;; Hmmm...Lisp Machine went down or forgot us.  Go away if it was a channel in active
;;; use.  If not, it is possible that it was a channel that failed to open correctly,
;;; in which case it was just timing out.  That's probably ok.
	TRZ IDX,1		;Check input and output
	SKIPL DATSTA(IDX)
	 SKIPGE DATSTA+1(IDX)
	  JRST CTLDON		;If either channel in use, Lisp Machine must have gone away.
	JRST CHNFLS		;Flush channels, then return

CHAOPN:	TRNE IDX,1              ;Reading or writing?
	 JRST CHAOPO            ;Writing, handle slightly differently
	TRNN TT,-1              ;Any output packets available?
	 POPJ P,                ;Nope, then done...just return
	PUSHJ P,REAONE          ;Handle the packet
	 JRST CHALOP            ;Loop if no error
	POPJ P,                 ;Else return

CHAOPO:	TLNN TT,-1              ;Any packets to read?
	 POPJ P,                ;Nope
	PUSHJ P,WRIONE
	 JRST CHALOP
	POPJ P,                 ;Error, return right away


IFN ITS,[
;;; IOC error handler

IOCINT:	.SUSET [.RBCHN,,T]	;Get channel that had error
	CAIL T,CHALOW
	 CAILE T,CHAHIG
	  JRST IOCDAT		;Not CHAOS channel, must be data error
	JRST CTLDON		;Else something happened to Lisp Machine, we are done

IOCDAT:	AOS -17(P)		;Setup to return to location after call which caused error
	.CALL [ SETZ
		SIXBIT /DISMIS/
		%CLBTW,,INTTAB
		%CLIN+%CLEND,,P]
	 .LOSE %LSSYS

;;; System going down and system being debugged inform user then exit to CTLLOP
DBGINT:	PUSHJ P,DWNIN1		;Set up to return notification
	MOVEI A,[ASCIZ/system being debugged./]
	SKIPN C
	 MOVEI A,[ASCIZ/system no longer being debugged./]
DWNIN2:	PUSHJ P,COMSTO
DWNIN9:	.CLOSE ERRCH,
	MOVEI T,CO%NOT
	PUSHJ P,COMSN1
	JRST CTLLOP

DWNIN1:	MOVE BP,[441000,,%CPKDT+CTLPKO]
	SETZ BC,
	.CALL [ SETZ ? 'SSTATU ? MOVEM B ? SETZM C ]
	 .LOSE %LSSYS
	POPJ P,

DWNINT:	PUSHJ P,DWNIN1
	MOVEI A,[ASCIZ/system revived./]
	JUMPL B,DWNIN2
	MOVEI A,[ASCIZ/system going down in /]
	PUSHJ P,COMSTO
	IDIVI B,30.
	IDIVI B,60.		;B minutes until down, C seconds
	SKIPN A,B
	 JRST DWNIN3
	PUSHJ P,COMDCO
	MOVEI A,[ASCIZ/ minutes, /]
	PUSHJ P,COMSTO
DWNIN3:	MOVE A,C
	PUSHJ P,COMDCO
	MOVEI A,[ASCIZ/ seconds./]
	PUSHJ P,COMSTO
	.OPEN ERRCH,[.UAI,,'SYS ? SIXBIT/DOWN/ ? SIXBIT/MAIL/]
	 JRST DWNIN9
	MOVEI BYTE,215
DWNIN4:	CAMGE BC,CHPMXC
	 CAIGE BYTE,40
	  CAIA
	   PUSHJ P,COMCHO
	.IOT ERRCH,BYTE
	JUMPL BYTE,DWNIN9	;EOF
	CAIN BYTE,15
	 MOVEI BYTE,215
	JRST DWNIN4
]	;END IFN ITS

IFN TNX,[
LEVTAB:	0,,PRILE1
	0,,PRILE2
	0,,PRILE3

CHNTAB:	3,,INTID0		;Interrupt IDX 0 (channel 0)
	3,,INTID1		;Interrupt IDX 1
	3,,INTID2
	3,,INTID3
	3,,INTID4
	3,,INTID5		;Interrupt IDX 5 (channel 6)
	0			;Arithmetic overflow
	0			;Floating overflow
	0			;Reserved for D.E.C.
	1,,CTLERR		;PDL overflow
	1,,CTLERR		;EOF
	1,,CTLERR		;Data error
	1,,CTLERR		;Disk full or quota exceeded
	0 ? 0			;Reserved
	1,,CTLERR		;Illegal instruction
	1,,CTLERR		;Illegal read
	1,,CTLERR		;Illegal write
	0			;Reserved
	1,,CTLERR		;Inferior termination or freeze
	1,,CTLERR		;System resources exhausted
	0			;Reserved
	0			;Reference to non-existant page
	3,,INTID6		;Interrupt IDX 6 (channel 23.)
	3,,INTID7
	3,,INTID8
	3,,INTID9
	3,,INTIDA		;Interrupt IDX 10. (channel 27.)
	3,,INTIDB
	3,,INTIDC		;IDX 12.
	3,,INTIDD		;IDX 13.
	3,,INTIDE		;IDX 14.
	3,,INTIDF		;IDX 15.
	3,,TIMINT		;Timer interrupt
	0 ? 0			;34. and 35. reserved by monitor if 
				; the job runs at toplevel

INDEX=0
IRPS NAME,,[0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F]
INTID!NAME: JSR LV1SAC		;Save AC's
	    MOVEI IDX,INDEX
	    JRST CHAIN0
INDEX=INDEX+1
TERMIN

CHAIN0:	PUSHJ P,CHALOP
INTDEB:	MOVE 0,[LV1ACS+1,,1]
	BLT 0,17
	MOVE 0,LV1ACS
	DEBRK

;Here with IDX properly set up
CHALOP:	MOVE 1,CHAJFN(IDX)
	GDSTS			;This gets state in 2, and number of input packets in 3
	 ERCAL CTLERR
	MOVE T,2
	HRLZ TT,3
	MOVE 1,CHAJFN(IDX)
	MOVEI 2,.MOAWS
	MTOPR
	 ERCAL CTLERR
	HRR TT,3
	JRST CHAIND(T)          ;Dispatch on state

;Timer interrupt
TIMINT:	JSR LV1SAC
	PUSHJ P,TIMIN1
	JRST INTDEB		;Dismiss interrupt

;;;Here to initialize the timer
TINTVL==2*60.*1000.		;Every two minutes
TIMRKS:	30. ? 15. ? 10. ? 5. ? 1. ? -30.	;Times at which to notify

TIMIN1:	SKIPL TIMINF		;Ok for timer interrupt?
	 JRST [	AOS TIMINF	;No, note that one went off
		JRST SETTIM]	;And skip downtime check for now
	PUSHJ P,DWNCHK
	JRST SETTIM

DWNCHK:
IFN 10X,MOVE 1,[SIXBIT /SYSTAT/]
.ELSE	MOVE 1,[SIXBIT /DWNTIM/]
	SYSGT
	HRRZ A,2		;Table number
	MOVE 1,A
IFN 10X,HRLI 1,27
	GETAB
	 SETZ 1,
	JUMPE 1,NODWNT
	MOVE C,1
	GTAD
	SUB C,1			;Get time until shutdown
	TLNE C,-1		;More than a day?
	 JRST NODWNT
IFN 10X,IDIVI C,60.		;Into minutes
.ELSE [
	IMULI C,24.*60.
	HLRZS C
]
	SETZ D,
	CAMG C,TIMRKS(D)	;Find range of time
	 AOJA D,.-1
	JUMPE D,NODWNT		;More than maximum time
	CAMN D,DWNTIM		;Same as last notification?
	 POPJ P,		;Yes
	MOVEM D,DWNTIM
	PUSHJ P,DWNIN1
	MOVEI A,[ASCIZ /system going down in /]
	PUSHJ P,COMSTO
	MOVE A,C
	PUSHJ P,COMDCO
	MOVEI A,[ASCIZ / minute/]
	PUSHJ P,COMSTO
	MOVEI BYTE,"s
	CAIE C,1
	 PUSHJ P,COMCHO
	MOVEI BYTE,".
	PUSHJ P,COMCHO
	JRST DWNIN2
	
NODWNT:	SKIPN DWNTIM
	 POPJ P,
	SETZM DWNTIM
	PUSHJ P,DWNIN1		;Set up to return notification
	MOVEI A,[ASCIZ/shutdown cancelled./]
	PUSHJ P,COMSTO
DWNIN2:	MOVEI T,CO%NOT
	JRST COMSN1

DWNIN1:	MOVE BP,[441000,,%CPKDT+CTLPKO]
	SETZ BC,
	POPJ P,

;; Setup timer interrupt
SETTIM:	
IFN 20X,[
	MOVE 1,[.FHSLF,,.TIMEL]	;Tick the timer
	MOVE 2,[TINTVL]
	MOVEI 3,33.		;On channel 33
	TIMER
	 JFCL
];IFN 20X
.ELSE [
IFNDEF IIT,IIT=JSYS 630
	MOVEI 1,.FHSLF		;This fork
	MOVEI 2,4		;On channel 33.
	MOVE 3,[TINTVL]
	IIT			; Set to trigger it
	POPJ P,
];10X
]	;END IFN TNX

;;; Character translation tables

;Byte is a pdp10 character to be sent to Lisp machine.
;This table used when not preceded by rubout escape.
;Skip once to ignore it, twice if this is rubout escape, three times for CR.
CHR2LM:	REPEAT 10, JFCL		;0 through 7, leave alone
	REPEAT 3, ADDI BYTE,200 ;10 through 12 turn into backspace, tab, linefeed
	JFCL                    ;13 stays as uparrow
	ADDI BYTE,200		;14 form
	JSP BYTE,[JRST 3(BYTE)]	;15 skip three times for carriage return
	REPEAT 177-16, JFCL	;16-176 unchanged
	JSP BYTE,[JRST 2(BYTE)]	;177 skip twice for quoting special character
IFN .-CHR2LM-200, .ERR CHR2LM table not 200 long

;This table used when preceded by rubout escape.
CHRQLM:	REPEAT 10, ADDI BYTE,200	;0-7 => 200-207
	REPEAT 3,JFCL		;10-12 self
	ADDI BYTE,200		;13 => 213
	REPEAT 2, JFCL		;14, 15 self
	REPEAT 177-16, ADDI BYTE,200	;16-176 => 216-376
	JFCL			;177 self
IFN .-CHRQLM-200, .ERR CHRQLM table not 200 long

;BYTE is a lisp-machine character to be put into pdp10 buffer via BP and BC
;Skip to ignore it.
CHR210:	REPEAT 10, JFCL		;0 through 7, leave alone
	REPEAT 3, PUSHJ P,CHRQ10	;10, 11, 12 hidden under backspace, tab, lf
	JFCL			;13 stays as uparrow
	REPEAT 2, PUSHJ P,CHRQ10	;14, 15 hidden under form, cr
	REPEAT 177-16, JFCL	;No change to 16 through 176
	REPEAT 11, PUSHJ P,CHRQ10	;177-207 quoted
	REPEAT 3, SUBI BYTE,200 ;Scale down to PDP-10 equivalents for 210 - 212
	PUSHJ P,CHRQ10		;213 quoted
	SUBI BYTE,200		;Scale down to PDP-10 equivalent for 214
	PUSHJ P,[MOVEI BYTE,15  ;Insert <CR><LF> for newline
		 IDPB BYTE,BP
		 ADDI BC,1
		 MOVEI BYTE,12
		 POPJ P,]
	REPEAT 377-216, PUSHJ P,CHRQ10	;216-376 quoted
	SKIPA			;377 ignored
IFN .-CHR210-400, .ERR CHR210 table not 400 long

CHRQ10:	TLNE A,ST.SUI		;Super-image mode
	 POPJ P,		;Just output byte with no quoting in super-image mode
	HRLM BYTE,(P)		;Output this byte preceded by 177 to quote it
	MOVEI BYTE,177
	IDPB BYTE,BP
	ADDI BC,1
	HLRZ BYTE,(P)
	POPJ P,

DEFINE INFORM A,B,C,D,E,F,G
PRINTX /A!B!C!D!E!F!G
/
TERMIN

DEFINE CONC A,B,C,D,E,F,G
A!B!C!D!E!F!G!TERMIN

;;; Start here to install
PURIFY:	SETZM DEBUG
IFN ITS,[
	MOVE T,[-<PURPND-NIMPUR>,,NIMPUR]
	.CALL [ SETZ ? 'CORBLK ? MOVEI %CBNDR ? MOVEI %JSELF ? T ? SETZI %JSELF ]
	 .LOSE %LSSYS
	.VALUE [ASCIZ/:PDUMP DSK:DEVICE;CHAOS FILE/]
];END IFN ITS
IFN TNX,[
	HLRO 1,JOBSYM		;Find end of symbol table
	MOVNS 1
	ADD 1,JOBSYM
	HRRZS 1
	CAIG 1,PURPND*1000
	 JRST PURIF1
	HRROI 1,[ASCIZ/Not enough space left for symbol table/]
	PSOUT
	HALTF

PURIF1:	MOVEI 1,.FHSLF
	MOVE 2,[1,,FILE]
	SEVEC
	MOVE 1,[GJ%SHT+GJ%FOU+GJ%NEW]
RADIX 10.
IFN 20X,HRROI 2,[CONC [ASCIZ /SYSTEM:CHAOS.FILE.],\.FVERS,/]
IFN 10X,HRROI 2,[CONC [ASCIZ /DSK:<SYSTEM>CHAOS.FILE;],\.FVERS,/]
RADIX 8
	GTJFN
	 HALTF
	HRLI 1,.FHSLF
	MOVEI 2,[ -NIMPUR,,520000	;Low impure copy on write
		  -<PURPND-NIMPUR>,,120000+NIMPUR	;Pure pages
		  0 ]			;End
	SSAVE
	HRROI 1,[ASCIZ/Saved.
/]
	PSOUT
	HALTF
]	;END IFN TNX

	CONSTANTS

IFN ITS,[
MFDBUF==:.\1777+1
PURPND==:MFDBUF/2000
DIRBUF==:MFDBUF+2000
BUFBAS==:<DIRBUF+2000>/2000
];END IFN ITS

IFN TNX,[
PURPND==:<<.+777>/1000>+NSYMPG
BUFBAS==:<PURPND*1000+1777>/2000
];TNX

PURLOC==.
LOC IMPLOC
	VARIABLES
IMPLOC==.
IFG .-PURBEG, .ERR TOO MUCH IMPURE, INCREASE NIMPUR

IF2,[
	INFORM END OF IMPURE=,\IMPLOC
	INFORM START OF PURE=,\PURBEG
	INFORM END OF PURE=,\PURLOC
	INFORM START OF BUFFERS=,\<BUFBAS*2000>
];IF2

IFN TNX, LOC PURLOC		;SEEMS TO CONTROL SYMBOL TABLE LOCATION

	END FILE
