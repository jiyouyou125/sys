;;; FILE job user program -*-Fail-*-
;;; ** (C) Copyright 1981 Symbolics, Inc.

IFNDEF TENEXF,<
TENEXF==0
IFE .OSFAIL-<SIXBIT/TENEX/>,<TENEXF==1>
>

DEFINE TENEX,<IFN TENEXF>
DEFINE NOTNX,<IFE TENEXF>

	SEARCH MONSYM

TENEX,<
	.INSER <CHAOS>CHASYM.MID
>
NOTNX,<
	.INSER UNV:CHASYM.MID
>

;;; Macros

TENEX,<
DEFINE COMND <JSYS .COMND##>		;Emulate COMND
DEFINE TEXTI <JSYS .TEXTI##>		; and TEXTI
>;TENEX

DEFINE FLDDB. (TYP,FLGS,DATA,HLPM,DEFM,LST,MSK) <
    ..XX==0
    IFDIF <FLGS>,<>,<..XX==FLGS>
    ..XX==<TYP>*1B8+..XX
    IFDIF <HLPM>,<>,<..XX_CM%HPP!..XX>
    IFDIF <DEFM>,<>,<..XX_CM%DPP!..XX>
    IFDIF <MSK>,<>,<..XX_CM%BRK!..XX>
    IFDIF <LST>,<>,<..XX+LST>
    IFIDN <LST>,<>,<..XX>
    IFDIF <DATA>,<>,<DATA>
    IFIDN <DATA>,<>,<0>
    IFDIF <HLPM>,<>,<HLPM>
    IFIDN <HLPM>,<>,<0>
    IFDIF <DEFM>,<>,<DEFM>
    IFIDN <DEFM>,<>,<0>
    IFDIF <MSK>,<>,<MSK>
>

DEFINE CMD ' (X,Y,Z) <
	IFIDN <Z>,<>,<
		IFIDN <Y>,<>,<[ASCIZ\X\],,.'X>
		IFDIF <Y>,<>,<[ASCIZ\X\],,Y>
	>
	IFDIF <Z>,<>,<
		IFIDN <Y>,<>,<[	Z
				ASCIZ\X\],,.'X>
		IFDIF <Y>,<>,<[	Z
				ASCIZ\X\],,Y>
	>
>

DEFINE CMD1 (X,Y,Z) <
	IFIDN <Z>,<>,<CMD (X,Y,<CM%FW>)>
	IFDIF <Z>,<>,<CMD (X,Y,<CM%FW!Z>)>
>

DEFINE TYPE (X) <
	UTYPE [ASCIZ/X/]
>
DEFINE CTYPE (X) <
	UTYPE 10,[ASCIZ/X/]
>
DEFINE CITYPE (X) <
	UTYPE 1,[ASCIZ/X/]
>
DEFINE ETYPE (X) <
	UETYPE [ASCIZ/X/]
>
DEFINE CETYPE (X) <
	UETYPE 10,[ASCIZ/X/]
>
DEFINE CIETYP (X) <
	UETYPE 1,[ASCIZ/X/]
>

DEFINE NOISE (X) <
	UNOI [ASCIZ/X/]
>

DEFINE DEFALT (X) <
	UDEF [ASCIZ/X/]
>

DEFINE PROMPT (X) <
	UPRMT [ASCIZ/X/]
>

DEFINE CONFRM <
	CALL CONF
>

DEFINE RETSKP <
	JRST CPOPJ1
>

DEFINE DEFERR (X,Y) <
	DEFINE X (Z) <
		IFIDN <Z>,<>,<UERR Y,0>
		IFDIF <Z>,<>,<UERR Y,[ASCIZ/Z/]>
	>
>

DEFERR WARN,3
DEFERR JWARN,7
DEFERR CERR,10
DEFERR JCERR,14
DEFERR ERROR,11
DEFERR JERROR,15
DEFERR FATAL,12
DEFERR JFATAL,16
DEFERR SNARL,13
DEFERR JSNARL,17

;;; AC's

F=0					;Flags
A=1
B=2
C=3
D=4
E=5
T=6
TT=7
U=10
V=11
W=12
L=13
N=14
BP=15
BC=16
P=17

F%CTL==1B0				;Control connection open
F%DAT==1B1				;Data connection open
F%IFI==1B2
F%OFI==1B3
F%TYP==1B4

;;;OPDEF's

OPDEF CALL [PUSHJ P,0]
OPDEF RET [POPJ P,0]
DEFINE CALLRET <JRST >

OPDEF PRINT [1B8]
OPDEF UTYPE [2B8]
OPDEF UETYPE [3B8]
OPDEF UERR [4B8]
OPDEF UNOI [5B8]
OPDEF UDEF [6B8]
OPDEF UPRMT [7B8]
OPDEF UHELP [10B8]

NPDL==177
PDL:	BLOCK NPDL
UUOACS:	BLOCK 20
TRANID:	0				;Transaction ID
CTLJFN:	0				;Control connection JFN
DATJFN:	0				;Data connection JFN
FILJFN:	0				;File jfn
HOST:	BLOCK 5
USER:	BLOCK 10
PASS:	BLOCK 10
IFH:	ASCII /I/
OFH:	ASCII /O/
PACKET:	BLOCK CHPMXW
RSPSTR:	BLOCK 2
ERRCOD:	0
ERRTYP:	0
DATMOD:	0
DATBSZ:	0

CSBFSZ==1000
CSBUF:	BLOCK CSBFSZ			;Command line buffer
CMDGTB:	BLOCK .GJATR+1			;GTJFN block
CMDFLB:	BLOCK 4				;Individual field block

STRBSZ==1000
STRBUF:	BLOCK STRBSZ			;Temporary string space
FILNAM:	BLOCK STRBSZ
FILNM1:	BLOCK STRBSZ
DIRVAR:
DIRDEL:	0
DIRPVM:	0
DIRLNK:	BLOCK 10
DIRBLK:	BLOCK 2
DIRBYT:	BLOCK 2
DIRBSZ:	0
DIRNBK:	0
DIRNRP:	0
DIRCRE:	BLOCK 5
;	DIRREF:	BLOCK 5
DIRAUT:	BLOCK 5
;	DIRRED:	BLOCK 5
DIRVRZ==.-1

CMDBLK:	CM%WKF+REPARS			;.CMFLG Flag bits,,Reparse dispatch adr
	.PRIIN,,.PRIOU			;.CMIOJ Input JFN,,Output JFN
	0				;.CMRTY Byte pointer to ^R text
	POINT 7,CSBUF			;.CMBFP Byte pointer to start of text
	POINT 7,CSBUF			;.CMPTR Byte pointer to next input
	CSBFSZ*5			;.CMCNT Count of space left in buffer
	0				;.CMINC Count of chars left in buffer
	POINT 7,STRBUF			;.CMABP Byte pointer to atom buffer
	STRBSZ*5			;.CMABC Size of atom buffer
	CMDGTB				;.CMGJB Address of GTJFN argument block

CMDRET:	JRST CMDRES

;;;Commands tables

CMDTAB:	NCMDS,,NCMDS 
	CMD ASCII
	CMD BINARY
	CMD BYTE-SIZE,.BYTES
	CMD CONNECT
	CMD DELETE
	CMD DIRECTORY
	CMD DISCONNECT
	CMD EXIT
	CMD GET
	CMD LOGIN
	CMD PDP-10,.PDP10
	CMD QUIT
	CMD RENAME
	CMD SEND
	CMD TYPE
NCMDS==.-CMDTAB-1

;;; Main loop
GO:	RESET
	SETZ F,
	MOVE P,[IOWD NPDL,PDL]
	MOVE A,[CALL UUOH]
	MOVEM A,.JB41##

CMDRES:	MOVE P,[IOWD NPDL,PDL]
	TLNE F,(F%IFI)			;UNWIND-PROTECT time
	 CALL CLSIFI
	TLNE F,(F%OFI)
	 CALL CLSOFI
	SKIPN A,FILJFN
	 JRST CMDLUP
	HRLI A,(CZ%ABT)
	CLOSF
	 JRST [	MOVE A,FILJFN
		RLJFN
		 JFCL
		JRST .+1]
	SETZM FILJFN
CMDLUP:	MOVEI A,[ASCIZ /CFTP>/]
	MOVE B,[CM%WKF+REPARS]
	CALL CMDINI
REPARS:	MOVE P,[IOWD NPDL,PDL]
	MOVEI A,CMDTAB
	CALL GETCMD
	CALL (A)
	JRST CMDLUP

.ASCII:	CONFRM
	SETZM DATMOD
	SETZM DATBSZ
	CALLRET SHOMOD

.BINAR:	CONFRM
	SETOM DATMOD
	SETZM DATBSZ
	CALLRET SHOMOD

.BYTES:	MOVEI B,[FLDDB. .CMNUM,,^D10]
	CALL CMDFLD
	CAIL B,1
	 CAILE B,^D16
	 CERR <Illegal byte size, must be 1 to 16 bits>
	PUSH P,B
	CONFRM
	SETOM DATMOD
	POP P,DATBSZ
	CALLRET SHOMOD

.PDP10:	CONFRM
	MOVEI A,1
	MOVEM A,DATMOD
	MOVEI B,^D9
	MOVEM B,DATBSZ
;	CALLRET SHOMOD

SHOMOD:	HRROI A,[ASCIZ /ASCII/]
	SKIPE DATMOD
	 HRROI A,[ASCIZ /Binary/]
	SETZ B,
	SKIPLE DATMOD
	 HRROI B,[ASCIZ /PDP-10 /]
	CIETYP <%2S%1S mode transfers>
	SKIPN A,DATBSZ
	 RET
	SKIPLE DATMOD
	 MOVEI A,^D36			;More correct
	ETYPE <; %1D bit bytes>
	RET

.DELET:	CALL CHKCON
	NOISE (FILE)
	CALL GETLIN
	MOVEI A,FILNAM
	CALL MOVATM
	CALL PROBEF
	HRROI B,[ASCIZ /DELETE/]
	SETZ C,
	CALL COMCTL
	MOVEI B,.CHNL
	BOUT
	HRROI B,FILNAM
	CALL COMSNL
	CALL COMSND
	CALL COMRSP
	HRROI A,FILNAM
	CIETYP (%1S deleted)
	RET

.RENAM:	CALL CHKCON
	NOISE (OLD FILE)
	CALL GETLIN
	MOVEI A,FILNAM
	CALL MOVATM
	CALL PROBEF
	MOVE A,[FILNAM,,FILNM1]
	BLT A,FILNM1+STRBSZ-1
	PROMPT (To be: )
	CALL GETLIN
	MOVEI A,FILNAM
	CALL MOVATM
	HRROI B,[ASCIZ /RENAME/]
	SETZ C,
	CALL COMCTL
	MOVEI B,.CHNL
	BOUT
	HRROI B,FILNM1
	CALL COMSNL
	HRROI B,FILNAM
	CALL COMSNL
	CALL COMSND
	CALL COMRSP
	CALL PROBEF
	HRROI A,FILNM1
	HRROI B,FILNAM
	CIETYP (%1S renamed to %2S)
	RET

.QUIT:	NOISE (TEMPORARILY)
	CONFRM
EXIT1:	HALTF
	RET

.EXIT:	NOISE (CLOSING CONNECTIONS)
	CALL .DISCO
	CALLRET EXIT1

.CONNE:	NOISE (TO HOST)
	CALL GETLIN
	MOVEI A,HOST
	CALL MOVATM
	CALL OPNCTL
	CITYPE (Connection open)
	CALLRET SHOMOD

.DISCO:	CONFRM
	CALLRET CLSALL

.LOGIN: CALL CHKCON
	NOISE (AS USER)
	CALL GETLIN
	MOVEI A,USER
	CALL MOVATM
	SETZM PASS
LOGIN1:	HRROI B,[ASCIZ /LOGIN /]
	SETZ C,
	CALL COMCTL
	HRROI B,USER
	CALL COMSNL
	HRROI B,PASS
	SOUT
	MOVEI B,.CHNL
	BOUT
	CALL COMSND
	CALL COMRS1
	 SKIPA
	 RET
	MOVE A,ERRCOD
	CAME A,[ASCII /IP?/]
	 CAMN A,[ASCII /PI?/]
	 SKIPA
	 ERROR (Error - %M)
	MOVEI A,.PRIIN			;Get current TTY mode
	RFMOD
	PUSH P,B			;Save for later
	TRZ B,TT%ECO!TT%ECM		;Kill echo
	SFMOD
	STPAR
	PROMPT (Password: )
	CALL GETLIN			;Get password string
	CALL CRLF			;Echo a CRLF
	MOVEI A,.PRIIN			;Restore echo
	POP P,B
	SFMOD
	STPAR
	MOVEI A,PASS
	CALL MOVATM
	JRST LOGIN1

CHKCON:	TLNE F,(F%CTL)
	 RET
	CERR (Not connected yet)

.TYPE:	SETZM DATMOD
	SETZM DATBSZ
	TLOA F,(F%TYP)
.GET:	TLZ F,(F%TYP)
	CALL CHKCON
	CALL CHKDAT
	NOISE (FOREIGN FILE)
	CALL GETLIN
	MOVEI A,FILNAM
	CALL MOVATM
	HRROI B,[ASCIZ /OPEN READ /]
	HRROI C,IFH
	CALL COMOPN
	TLO F,(F%IFI)
	TLZE F,(F%TYP)
	 JRST TYPE1
	PROMPT (To local file: )
	MOVEI B,[FLDDB. .CMOFI]
	CALL CMDFLD
	MOVEM B,FILJFN
NOTNX,<				;Compensate for bug in COMND emulator
	CONFRM
>
	SKIPE B,DATBSZ
	 JRST .+4
	MOVEI B,7
	SKIPE DATMOD
	 MOVEI B,^D16
	LSH B,^D30
	HRRI B,OF%WR
	MOVE A,FILJFN
	OPENF
	 JERROR (Cannot open local file)
	HRROI B,FILNAM
	CIETYP (Transferring %2S to %1J)
	CALL REDLUP
	MOVE A,FILJFN
	SKIPLE DATMOD
	 JRST [	HRLI A,(CO%NRJ)
		CLOSF
		 JERROR
		HRRZS A
		SIZEF
		 JERROR
		LSH B,-2
		MOVE C,B
		SETO B,
		HRLI A,.FBSIZ
		CHFDB
		HRLI A,.FBBYV
		MOVSI B,(FB%BSZ)
		MOVSI C,(44B11)
		CHFDB
		HRRZS A
		RLJFN
		 JERROR
		JRST .+3]
	CLOSF
	 JERROR
GET1:	SETZM FILJFN

CLSIFI:	HRROI B,[ASCIZ /CLOSE/]
	HRROI C,IFH
	CALL COMCTL
	CALL COMSND
	CALL COMRSP
	CALL SMRKIN
	TLZ F,(F%IFI)
	RET

TYPE1:	MOVEI A,.PRIOU
	MOVEM A,FILJFN
	CALL REDLUP
	JRST GET1

PROBEF:	HRROI B,[ASCIZ /OPEN PROBE/]
	SETZ C,
	CALL COMCTL
	JRST COMOP1

COMOPN:	CALL COMCTL
	HRROI B,[ASCIZ /CHARACTER/]
	SKIPE DATMOD
	 HRROI B,[ASCIZ /BINARY/]
	SETZ C,
	SOUT
	SKIPN DATBSZ
	 JRST COMOP1
	HRROI B,[ASCIZ / BYTE-SIZE /]
	SOUT
	MOVE B,DATBSZ
	MOVEI C,^D10
	NOUT
	 JERROR
COMOP1:	MOVEI B,.CHNL
	BOUT
	HRROI B,FILNAM
	CALL COMSNL
	CALL COMSND
	CALL COMRSP
	CALLRET GETTRU

.SEND:	CALL CHKCON
	CALL CHKDAT
	NOISE (LOCAL FILE)
	MOVEI B,[FLDDB. .CMIFI]
	CALL CMDFLD
	MOVEM B,FILJFN
	CONFRM
	SKIPE B,DATBSZ
	 JRST .+4
	MOVEI B,7
	SKIPE DATMOD
	 MOVEI B,^D16
	LSH B,^D30
	HRRI B,OF%RD
	MOVE A,FILJFN
	OPENF
	 JERROR (Cannot open local file)
	PROMPT (To foreign file: )
	CALL GETLIN
	MOVEI A,FILNAM
	CALL MOVATM
	HRROI B,[ASCIZ /OPEN WRITE /]
	HRROI C,OFH
	CALL COMOPN
	TLO F,(F%OFI)
	CALL WRTLUP
	CALL CLSOFI
	CALL GETTRU
	MOVE A,FILJFN
	HRROI B,FILNAM
	CIETYP (%1J transferred to %2S)
	CLOSF
	 JERROR
	SETZM FILJFN
	RET

CLSOFI:	HRROI B,[ASCIZ /CLOSE/]
	HRROI C,OFH
	CALL COMCTL
	CALL COMSND
	CALL SNDSYN
	CALL COMRSP
	TLZ F,(F%OFI)
	RET

DIRTAB:	NDIRIN,,NDIRIN
	[ASCIZ /AUTHOR/],,DIRAUT
	[ASCIZ /BYTE-SIZE/],,DIRBSZ
	[ASCIZ /CREATION-DATE/],,DIRCRE
	[ASCIZ /DELETED/],,DIRDEL
	[ASCIZ /DONT-REAP/],,DIRNRP
	[ASCIZ /LENGTH-IN-BLOCKS/],,DIRBLK
	[ASCIZ /LENGTH-IN-BYTES/],,DIRBYT
	[ASCIZ /LINK-TO/],,DIRLNK
	[ASCIZ /NOT-BACKED-UP/],,DIRNBK
	[ASCIZ /PHYSICAL-VOLUME/],,DIRPVM
;	[ASCIZ /READER/],,DIRRED
;	[ASCIZ /REFERENCE-DATE/],,DIRREF
NDIRIN==.-DIRTAB-1

.DIREC:	CALL CHKCON
	CALL CHKDAT
	NOISE (OF FILES)
	CALL GETLIN
	MOVEI A,FILNAM
	CALL MOVATM
	HRROI B,[ASCIZ /DIRECTORY/]
	HRROI C,IFH
	CALL COMCTL
	MOVEI B,.CHNL
	BOUT
	HRROI B,FILNAM
	CALL COMSNL
	CALL COMSND
	CALL COMRSP
	TLO F,(F%IFI)
	SETZ BC,
DIRLUP:	SETZM FILNAM
	SETZM DIRVAR
	MOVE A,[DIRVAR,,DIRVAR+1]
	BLT A,DIRVRZ
	MOVE A,[POINT 7,FILNAM]
	CALL DATLIN
	 JRST CLSIFI
DIRLP1:	MOVE C,[POINT 7,STRBUF]
DIRLP2:	CALL DATBYT
	 RET
	CAIE B,40
	 CAIN B,.CHNL
	 JRST DIRLP3
	IDPB B,C
	JRST DIRLP2
DIRLP3:	CAMN C,[POINT 7,STRBUF]
	 JRST DIRPRT
	MOVE D,B		;Save terminator char
	SETZ B,
	IDPB B,C
	MOVEI A,DIRTAB
	HRROI B,STRBUF
	TBLUK
	TLNN B,(TL%EXM)
	 JRST DIRFLL
	HRRZ A,(A)
	CAIN D,.CHNL
	 JRST [	MOVE A,[ASCIZ /T/]
		MOVEM A,(A)
		JRST DIRLP1]
	HRLI A,(<POINT 7,0>)
	CALL DATLIN
	 JFCL
	JRST DIRLP1

DIRFLL:	CALL DATBYT
	 RET
	CAIE B,.CHNL
	 JRST DIRFLL
	JRST DIRLP1

DIRPRT:	SKIPN FILNAM
	 JRST DIRLUP
	CALL CRIF
	MOVEI A," "
	SKIPN B,DIRDEL
	 MOVE B,[ASCIZ /NIL/]
	CAME B,[ASCIZ /NIL/]
	 MOVEI A,"D"
	PBOUT
	MOVEI A," "
	PBOUT
	HRROI A,DIRPVM
	PSOUT
	MOVEI C,6
	CALL DIRPOS
	HRROI A,FILNAM
	PSOUT
	MOVEI C,^D20
	CALL DIRPOS
	SKIPE DIRLNK
	 JRST DIRPLK
	HRROI A,DIRBLK
	MOVEI D,4
	CALL DIRNUM
	MOVEI A," "
	PBOUT
	HRROI A,DIRBYT
	MOVEI D,6
	CALL DIRNUM
	MOVEI A,"("
	PBOUT
	HRROI A,DIRBSZ
	PSOUT
	MOVEI A,")"
	PBOUT
	MOVEI C,^D39
	CALL DIRPOS
	MOVEI A," "
	SKIPN B,DIRNBK
	 MOVE B,[ASCIZ /NIL/]
	CAME B,[ASCIZ /NIL/]
	 MOVEI A,"!"
	PBOUT
	MOVEI A," "
	SKIPN B,DIRNRP
	 MOVE B,[ASCIZ /NIL/]
	CAME B,[ASCIZ /NIL/]
	 MOVEI A,"$"
	PBOUT
DIRPL1:	HRROI A,DIRCRE
	PSOUT
	MOVEI C,^D59
	CALL DIRPOS
	HRROI A,DIRAUT
	PSOUT
	CALL CRLF
	JRST DIRLUP

DIRPLK:	HRROI A,[ASCIZ /=> /]
	PSOUT
	HRROI A,DIRLNK
	PSOUT
	MOVEI C,^D41
	CALL DIRPOS
	JRST DIRPL1

DIRPOS:	MOVEI A,.PRIOU
	RFPOS
	SUBI C,(B)
	MOVEI B," "
	BOUT
	SOJG C,.-1
	RET

DIRNUM:	MOVEI C,^D10
	NIN
	 RET
	MOVEI A,.PRIOU
	HRLI C,(NO%LFL)(D)
	NOUT
	 JERROR
	RET

;;;Move a string from B to A

MOVSTR:	HRLI B,(<POINT 7,0>)
	JRST MOVST1
MOVST3:	IDPB C,A
MOVST1:	ILDB C,B
	JUMPN C,MOVST3
	RET

;;;Move atom buffer
MOVATM:	HRLI A,(<POINT 7,0>)
	MOVEI B,STRBUF

;;;Move string and terminating null

MOVST0:	HRLI B,(<POINT 7,0>)
MOVST2:	ILDB C,B
	IDPB C,A
	JUMPN C,MOVST2
	RET

;;;UUO handler

UUOH:	MOVEM 16,UUOACS+16		;Save all AC's
	MOVEI 16,UUOACS
	BLT 16,UUOACS+15
	LDB A,[POINT 9,.JBUUO##,8]	;Get opcode field
	CAIL A,MAXUUO
	 SETZ A,			;UUO is illegal
	CALL @UUOS(A)			;Do the right routine
	MOVSI 16,UUOACS			;Restore ac's
	BLT 16,16
	RET

UUOS:	%ILUUO
	%PRINT
	%TYPE
	%ETYPE
	%ERROR
	%NOISE
	%DEFAL
	%PRMPT
	%HELP
MAXUUO==.-UUOS

%ILUUO:	HRROI A,[ASCIZ/Illegal UUO /]
	ESOUT
	MOVEI A,.PRIOU
	MOVE B,.JBUUO
	MOVE C,[NO%ZRO+<^D12,,^D8>]
	NOUT
	 NOP
	HRROI A,[ASCIZ/ at /]
	PSOUT
	MOVEI A,.PRIOU
	SOS B,-1(P)			;Get failing PC
	MOVE C,[NO%ZRO+<6,,^D8>]
	NOUT
	 NOP
	HALTF
	RET

EOL==:37				;Newline for PRINT UUO

%PRINT:	HRRZ A,.JBUUO			;Get byte
	CAIN A,EOL			;Print EOL means do CRLF
	 JRST CRLF
%PRIN0:	PBOUT
	RET

%TYPE:	CALL TYCRIF			;Check if we should do a CRLF
%TYPE0:	HRRO A,.JBUUO			;Get string
	PSOUT
	RET

%PRMPT: HRRZ A,.JBUUO			;Get prompt string
	SETZ B,
	CALL CMDINI			;Setup that as prompt
	RET

TYCRIF:	MOVE A,.JBUUO			;Get instruction
	TLNE A,(<10,0>)			;Wants cr all the time?
	 JRST CRLF			;Yes
	TLNE A,(<1,0>)			;Wants fresh line?
	 JRST CRIF			;Yes
	RET

CRIF:	PUSH P,A
	PUSH P,B
	MOVEI A,.PRIOU
	RFPOS
	HRROI A,CRLF0
	TRNE B,-1			;If not at start of line,
	 PSOUT				;Type crlf
POP21J:	POP P,B
CPOP1J:	POP P,A
CPOPJ:	RET

CRLF:	PUSH P,A
	HRROI A,CRLF0
	PSOUT
CPOPAJ:	POP P,A
	RET

CRLF0:	ASCIZ/
/

%ERROR:	CALL CRIF			;Get a fresh line
	MOVE B,.JBUUO			;Get instruction
	TLNE B,(<10,0>)			;Wants %?
	 SKIPA A,["?"]			;No
	  MOVEI A,"%"
	PBOUT
	TRNN B,-1			;Any message to print?
	 JRST %ERR2			;No
	CALL %ETYE0			;Yes, print it out
	MOVE B,.JBUUO			;And recover instruction
%ERR2:	TLNN B,(<4, 0>)			;Wants JSYS error message?
	 JRST %ERR3
	HRROI A,[ASCIZ/ - /]
	TRNE B,-1			;If a previous message, type delimiter
	 PSOUT
	MOVEI A,.PRIOU
	HRLOI B,.FHSLF			;This fork
	SETZ C,
	ERSTR
	 NOP
	 NOP
	MOVEI A,.FHSLF			;Yes, check last error
	GETER
	HRRZS B				;Only want error code
	CAIL B,NPXAMB			;One of the CM%NOP errors?
	 CAILE B,NPXCMA
	  JRST %ERR3			;No, don't type atom buffer
	LDB A,[POINT 7,STRBUF,6]	;Look like anything in atom buffer?
	JUMPE A,%ERR3			;No, don't type it then
	HRROI A,[ASCIZ/ - "/]
	PSOUT
	HRROI A,STRBUF			;Now output atom buffer
	PSOUT
	HRROI A,[ASCIZ/"
/]
	PSOUT
%ERR3:	LDB A,[POINT 2,.JBUUO,12]	;Get low order bits of ac field
	XCT %ERRS(A)
	JRST %FATAL			;Shouldn't happen

%ERRS:	JRST CMDRES			;0 - return to top level commands
%ERRET:	XCT CMDRET			;1 - user settable return
	JRST %FATAL			;2 - return to exec
	RET				;3 - return to user

%FATAL:	HALTF
	HRROI A,[ASCIZ/Can't continue
/]
	ESOUT
	JRST %FATAL

%ETYPE:	CALL TYCRIF			;Type a CR maybe
%ETYE0:	HRRZ U,.JBUUO
%ETYS0:	HRLI U,(<POINT 7,0>)		;Get byte pointer to string
%ETYP1:	ILDB A,U			;Get char
	JUMPE A,CPOPJ			;Done
	CAIE A,"%"			;Escape code?
	 JRST %ETYP0			;No, just print it out
	SETZ V,				;Reset ac
%ETYP2:	ILDB A,U
	CAIL A,"0"			;Is it part of addr spec?
	 CAILE A,"7"
	  JRST %ETYP3			;No
	IMULI V,10			;Yes, increment address
	ADDI V,-"0"(A)
	JRST %ETYP2
%ETYP3:	CAIG A,"Z"
	 CAIGE A,"A"
	  JRST %ETYP0
	CALL @%ETYTB-"A"(A)		;Do dep't thing
	JRST %ETYP1

%ETYP0:	PBOUT
	JRST %ETYP1

%ETYTB:	%ETYPA				;A - Print time
	%ETYPB				;B - Print date
	%ETYP0				;C
	%ETYPD				;D - print decimal
	%ETYER				;E - error code
	%ETYPF				;F - floating
	%ETYP0				;G
	%ETYPH				;H - RH as octal
	%ETYP0				;I
	%ETYPJ				;J - filename
	REPEAT 2,<%ETYP0>		;K, L
	%ETYPM				;M - last server error msg
	%ETYP0				;N
	%ETYPO				;O - octal
	%ETYPP				;P - pluralizer
	REPEAT 2,<%ETYP0>		;Q, R
	%ETYPS				;S - string
	%ETYPT				;T - date and time
	%ETYPU				;U - user name
	REPEAT 5,<%ETYP0>		;V, W, X, Y, Z

%ETYPA:	MOVSI C,(OT%NDA)		;No day, just time
	JRST %ETYB0

%ETYPT:	TDZA C,C			;Both date and time
%ETYPB:	 MOVSI C,(OT%NTM)		;No time, just day
%ETYB0:	JUMPE V,.+2			;If ac field spec'd
	 SKIPA B,UUOACS(V)		;Use it
	  SETO B,			;Else use now
	MOVEI A,.PRIOU
	ODTIM
	RET

%ETYPD:	SKIPA C,[^D10]			;Decimal
%ETYPO:	 MOVEI C,^D8			;Octal
	MOVE B,UUOACS(V)		;Get data
%ETYO0:	MOVEI A,.PRIOU
	NOUT
	 NOP
	RET

%ETYER:	MOVEI A,.PRIOU
	MOVSI B,.FHSLF			;This fork
	HRR B,UUOACS(V)			;Get error code
	ERSTR
	 NOP
	 NOP
	RET

%ETYPM:	MOVEI A,.PRIOU
	DMOVE B,RSPSTR
	SOUT
	RET

%ETYPF:	MOVEI A,.PRIOU
	MOVE B,UUOACS(V)
	SETZ C,
	FLOUT
	 NOP
	RET

%ETYPH:	MOVEI C,^D8
	HRRZ B,UUOACS(V)
	JRST %ETYO0

%ETYPJ:	MOVEI A,.PRIOU
	HRRZ B,UUOACS(V)
	MOVE C,[211110,,1]		;Def dev, frc, dir, name, etc
	JFNS
	RET

%ETYPP:	MOVEI A,"s"
	MOVE B,UUOACS(V)
	CAIE B,1
	 PBOUT				;Make plural unless just one
	RET

%ETYPS:	PUSH P,U
	SKIPE U,UUOACS(V)
	 CALL %ETYS0			;Recursive call
CPOPUJ:	POP P,U
	RET

%ETYPU:	MOVEI A,.PRIOU
	MOVE B,UUOACS(V)
	DIRST
	 NOP
	RET

;;;Command parsing routines

$COMND: MOVEI A,CMDBLK
	COMND
	RET

;;;Initialize command line
CMDINI:	HRROM A,CMDBLK+.CMRTY		;Set up prompt string
	MOVEM B,CMDBLK+.CMFLG
	MOVEI B,[FLDDB. .CMINI]		;Init command block
	CALLRET $COMND

CONF:	MOVEI B,CNFCMD			;Get confirmation
	CALLRET CMDFLD

CNFCMD:	FLDDB. .CMCFM

;;;Normal command levels
GETCMD:	HRRZM A,CMDFLB+.CMDAT		;Address of keyword table
	SETZM CMDFLB+.CMFNP		;.CMKEY = 0
	CALL CMDNO2			;Parse the field
	SETZM CMDFLB+.CMHLP		;Reset default and help messages
	SETZM CMDFLB+.CMDEF
	HRRZ A,(B)			;Get address of routine
	RET

;;;Parse noise word
%NOISE:	MOVSI A,(<BYTE (9) .CMNOI,0>)
	MOVEM A,CMDFLB+.CMFNP
	HRRO A,.JBUUO
CMDNO1:	MOVEM A,CMDFLB+.CMDAT
CMDNO2:	MOVSI A,(CM%DPP)
	SKIPE CMDFLB+.CMDEF		;Default provided?
	 IORM A,CMDFLB+.CMFNP		;Yes, say there is one
	MOVSI A,(CM%HPP)
	SKIPE CMDFLB+.CMHLP		;Help provided?
	 IORM A,CMDFLB+.CMFNP		;Yes, say there is help
	MOVEI B,CMDFLB
;	CALLRET CMDFLD

;;;Parse an arbitrary field
CMDFLD:	CALL $COMND
	TLNE A,(CM%NOP)
	 JERROR				;Give JSYS error message and return
	RET				;Did ok

;;;Set up a default
%DEFAL:	HRRZ B,.JBUUO
	HRROM B,CMDFLB+.CMDEF		;Save default string
	MOVSI A,(CM%DPP)
	IORM A,CMDFLB+.CMFNP		;Yes, say there is one
	RET

;;;Set up help string
%HELP:	HRRZ B,.JBUUO
	HRROM B,CMDFLB+.CMHLP		;Save help string
	MOVSI B,(CM%HPP)
	IORM B,CMDFLB+.CMFNP		;Say there is help
	RET

;;;Read in a text line
GETLIN:	MOVEI B,[FLDDB. .CMTXT]		;Get a text line
	CALL CMDFLD
	TLNN A,(CM%RPT)
	 RET
	JRST GETLIN			;Sigh

;;; Chaosnet stuff
.CHNL==215
.COSYN==201
.COASY==202
.CONOT==203

OPNCTL:	CALL CLSALL
	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ /CHA:/]
	CALL MOVSTR
	MOVEI B,HOST
	CALL MOVSTR
	MOVEI B,[ASCIZ /.FILE_1/]
	CALL MOVST0
	MOVSI A,(GJ%SHT)
	HRROI B,STRBUF
	GTJFN
	 JERROR (Cannot get connection)
	MOVE B,[8B5+OF%RD+OF%WR]
	OPENF
	 JERROR (Cannot open connection)
	MOVEM A,CTLJFN
	SETZM TRANID
	TLO F,(F%CTL)
	RET

CLSALL:	TLNE F,(F%DAT)
	 CALL CLSDAT
	TLNE F,(F%CTL)
	 CALL CLSCTL
	RET

CLSCTL:	MOVE A,CTLJFN
	MOVEI B,.MOEOF
	MTOPR
	 ERJMP .+1
	CLOSF
	 JFCL
	TLZ F,(F%CTL)
	RET

CHKDAT:	TLNE F,(F%DAT)
	 RET
OPNDAT:	GJINF
	MOVE B,C
	MOVE A,[POINT 7,IFH,6]
	MOVEI C,^D10
	NOUT
	 JFATAL
	MOVE A,[POINT 7,OFH,6]
	NOUT
	 JFATAL
	HRROI B,[ASCIZ /DATA-CONNECTION /]
	SETZ C,
	CALL COMCTL
	HRROI B,IFH
	SOUT
	MOVEI B,40
	BOUT
	HRROI B,OFH
	SOUT
	CALL COMSND
	HRROI A,STRBUF
	HRROI B,[ASCIZ /CHA:./]
	SETZ C,
	SOUT
	HRROI B,OFH
	SOUT
	SETZ B,
	IDPB B,A
	MOVSI A,(GJ%SHT)
	HRROI B,STRBUF
	GTJFN
	 JERROR (Cannot get data connection)
	MOVE B,[8B5+OF%RD+OF%WR]
	OPENF
	 JERROR (Cannot open data connection)
	MOVEM A,DATJFN
	MOVEI B,.MOOPN
	MTOPR
	CALL COMRSP
	TLO F,(F%DAT)
	RET

CLSDAT:	MOVE A,DATJFN
	CLOSF
	 JFCL
	TLZ F,(F%DAT)
	RET

COMCTL:	PUSH P,B		;Command name
	PUSH P,C		;File handle
	MOVE A,CTLJFN
	MOVEI B,"T"
	BOUT
	AOS B,TRANID
	MOVEI C,^D10
	NOUT
	 JFATAL
	MOVEI B,40
	BOUT
	POP P,B
	SETZ C,
	SKIPE B
	 SOUT
	MOVEI B,40
	BOUT
	POP P,B
	SOUT
	RET

COMSNL:	MOVE A,CTLJFN
	SETZ C,
	SOUT
	MOVEI B,.CHNL
	BOUT
	RET

COMSND:	MOVE A,CTLJFN
	MOVEI B,.MOSND
	MTOPR
	RET

COMRSP:	CALL COMRS1
	 ERROR (Error - %M)
	RET

COMRS1:	CALL CTLPKR
COMRSE:	MOVE B,[POINT 8,PACKET+CHPKDT]
	LDB C,[PACKET+$CPKNB]
	CALL RSPATM		;TID
	CALL RSPATM		;FH
	CALL RSPATM
	CAME A,[ASCII /ERROR/]
	 JRST [	AOS (P)
		JRST COMRS2]
	CALL RSPATM
	MOVEM A,ERRCOD
	CALL RSPATM
	LSH A,-^D29
	MOVEM A,ERRTYP
COMRS2:	MOVN C,C
	DMOVEM B,RSPSTR
	RET

CTLPKR:	MOVE A,CTLJFN
	MOVEI B,.MOPKR
	MOVEI C,PACKET
	MTOPR
	LDB B,[PACKET+$CPKOP]
	CAIN B,.CODAT
	 RET
	CAIN B,.COASY
	 JRST ASYERR
	MOVE C,[POINT 8,PACKET+CHPKDT]
	LDB D,[PACKET+$CPKNB]
	MOVN D,D
	DMOVEM C,RSPSTR
	CAIN B,.CONOT
	 JRST CTLNOT
	CALL CLSALL
	CAIN B,.COLOS
	 ERROR (Connection lose - %M)
	CAIN B,.COCLS
	 ERROR (Connection closed - %M)
	ERROR (Received packet with unknown opcode - %2O)

CTLNOT:	WARN (File server - %M)
	JRST CTLPKR

RSPATM:	SETZ A,
	MOVE T,[POINT 7,A]
	MOVEI TT,5
RSPAT1:	SOJL C,CPOPJ
	ILDB D,B
	CAIN D,40
	 RET
	SOJL TT,RSPATM
	IDPB D,T
	JRST RSPAT1

GETTRU:	DMOVE B,RSPSTR
GETTR1:	AOJG C,[ERROR (Badly formatted response)]
	ILDB D,B
	CAIE D,.CHNL
	 JRST GETTR1
	MOVE A,[POINT 7,FILNAM]
GETTR3:	AOJG C,GETTR2
	ILDB D,B
	CAIN D,.CHNL
	 JRST GETTR2
	IDPB D,A
	JRST GETTR3
GETTR2:	SETZ D,
	IDPB D,A
	RET

ASYERR:	CALL COMRSE
	ERROR (Error - %M)

REDLUP:	SKIPN DATMOD
	 JRST REDASC
REDBIN:	CALL DATPKR
	 RET
	MOVE A,FILJFN
	MOVE B,[POINT 16,PACKET+CHPKDT]
	LDB C,[$CPKNB+PACKET]
	LSH C,-1
	MOVN C,C
	SOUT
	JRST REDBIN

DATPKR:	PUSH P,A
	PUSH P,C
	MOVE A,DATJFN
	MOVEI B,.MOPKR
	MOVEI C,PACKET
	MTOPR
	POP P,C
	POP P,A
	LDB T,[$CPKOP+PACKET]
	CAIN T,.COEOF
	 RET
	CAIN T,.COASY
	 JRST ASYERR
	CAIE T,.CODAT
	 CAIN T,.CODAT+100
	 SKIPA
	 JRST [	ERROR (Received packet with unknown opcode)]
CPOPJ1:	AOS (P)
	RET

REDASC:	SETZ BC,
REDAS1:	CALL DATBYT
	 RET
	MOVE A,FILJFN
	XCT LM2ASC(B)
	 BOUT
	JRST REDAS1

DATBYT:	SOJGE BC,[ILDB B,BP
		  RETSKP]
	CALL DATPKR
	 RET
	MOVE BP,[POINT 8,PACKET+CHPKDT]
	LDB BC,[PACKET+$CPKNB]
	JRST DATBYT

DATLIN:	CALL DATBYT		;Get first byte
	 RET			;Eof at first
DATLN1:	CAIN B,.CHNL
	 JRST DATLNF
	IDPB B,A
	CALL DATBYT
	 SKIPA
	 JRST DATLN1
DATLNF:	SETZ B,
	IDPB B,A
	RETSKP

LM2ASC:	REPEAT 10,<JFCL>	;0 through 7, leave alone
	REPEAT 3,<CALL CHRQ10>	;10, 11, 12 hidden under backspace, tab, lf
	JFCL			;13 stays as uparrow
	REPEAT 2,<CALL CHRQ10>	;14, 15 hidden under form, cr
	REPEAT 177-16,<JFCL>	;No change to 16 through 176
	REPEAT 11,<CALL CHRQ10>	;177-207 quoted
	REPEAT 3,<SUBI B,200>	;Scale down to PDP-10 equivalents for 210 - 212
	CALL CHRQ10		;213 quoted
	SUBI B,200		;Scale down to PDP-10 equivalent for 214
	CALL [	MOVEI B,15	;Insert <CR><LF> for newline
		BOUT
		MOVEI B,12
		RET]
	REPEAT 377-216,<CALL CHRQ10>	;216-376 quoted
	SKIPA			;377 ignored

CHRQ10:	HRLM B,(P)		;Output this B preceded by 177 to quote it
	MOVEI B,177
	BOUT
	HLRZ B,(P)
	POPJ P,

SMRKIN:	MOVE A,DATJFN
	MOVEI B,.MOPKR
	MOVEI C,PACKET
	MTOPR
	LDB T,[$CPKOP+PACKET]
	CAIN T,.COSYN
	 RET
	CAIN T,.COASY
	 JRST ASYERR
	CAIE T,.CODAT
	 CAIN T,.COEOF
	 JRST SMRKIN
	ERROR (Received packet with unknown opcode)

WRTLUP:	SKIPE DATMOD
	 JRST WRTBIN
WRTASC:	MOVE A,FILJFN
	BIN
	 ERJMP WRTEOF
	MOVE A,DATJFN
	SKIPN DATMOD
	 XCT ASC2LM(B)
	 BOUT
	JRST WRTASC

WRTBIN:	MOVE A,FILJFN
	MOVE B,[POINT 16,PACKET+CHPKDT]
	MOVNI C,<CHPMXC/2>
	SIN
	ADDI C,<CHPMXC/2>
	JUMPE C,WRTEOF
	LSH C,-1		;Compute byte count
	DPB C,[$CPKNB+PACKET]
	MOVEI T,.CODAT+100
	DPB T,[$CPKOP+PACKET]
	MOVE A,DATJFN
	MOVEI B,.MOPKS
	MOVEI C,PACKET
	MTOPR
	JRST WRTBIN

ASC2LM:	REPEAT 10,<JFCL>	;0 through 7, leave alone
	REPEAT 3,<ADDI B,200>	;10 through 12 turn into backspace, tab, etc.
	JFCL                    ;13 stays as uparrow
	ADDI B,200		;14 form
	CALL [	MOVE A,FILJFN
		BIN
		MOVE A,DATJFN
		MOVEI B,.CHNL
		RET]		;15 carriage return
	REPEAT 177-16,<JFCL>	;16-176 unchanged
	CALL ASC2QT		;177 special quoting character

ASC2QT:	MOVE A,FILJFN
	BIN
	XCT ASC2Q1(B)
	MOVE A,DATJFN
	RET

ASC2Q1:	REPEAT 10,<ADDI B,200>	;0-7 => 200-207
	REPEAT 3,<JFCL>		;10-12 self
	ADDI B,200		;13 => 213
	REPEAT 2,<JFCL>		;14, 15 self
	REPEAT 177-16,<ADDI B,200>	;16-176 => 216-376
	JFCL			;177 self

WRTEOF:	MOVE A,DATJFN
	MOVEI B,.MOEOF
	MTOPR
	MOVEI B,.MONOP
	MTOPR
	RET

SNDSYN:	MOVSI A,(<BYTE (8) .COSYN,0>)
	MOVEM A,PACKET
	MOVE A,DATJFN
	MOVEI B,.MOPKS
	MOVEI C,PACKET
	MTOPR
	RET

END GO
